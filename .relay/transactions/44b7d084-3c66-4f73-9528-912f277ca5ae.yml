uuid: 44b7d084-3c66-4f73-9528-912f277ca5ae
projectId: google-ai-studio-notification
createdAt: '2025-08-05T13:04:24.745Z'
linesAdded: 132
linesRemoved: 25
gitCommitMsg: 'feat: add pause and resume to floating indicator'
promptSummary: >-
  The user wants to add a pause and resume feature to the floating indicator
  component in the Chrome extension.
reasoning:
  - >-
    Of course! I can add a pause and resume feature to the floating indicator.
    This will involve updating the state management in `App.tsx`, adding the UI
    controls to `Indicator.tsx`, and updating the shared types and constants.
    Here are the necessary changes:
  - >-
    First, I'll update the `Status` type to include `'paused'` and modify the
    `IndicatorProps` to accept a callback for pausing and resuming.
  - >-
    Next, I'll add a new configuration for the `'paused'` state, giving it a
    distinct color and text. I'll use orange for this.
  - >-
    Now, I'll update the `Indicator` component. This change adds the
    pause/resume button, displays the timer in more states (paused and stopped),
    and replaces the close button's text with an SVG icon for a cleaner look.
  - >-
    Finally, I'll replace the logic in `App.tsx` to handle the new `paused`
    state, manage the timer correctly across pauses, and prevent state checks
    while paused.
  - >-
    These changes introduce the pause/resume functionality to the floating
    indicator as you requested. Let me know if you have any other questions!
operations:
  - type: write
    path: src/content/types.ts
    content: >-
      <<<<<<< SEARCH

      export type Status = 'monitoring' | 'running' | 'stopped' | 'error';

      =======

      export type Status = 'monitoring' | 'running' | 'stopped' | 'error' |
      'paused';

      >>>>>>> REPLACE

      <<<<<<< SEARCH

      export interface IndicatorProps {
        status: Status;
        error: string | null;
        elapsedTime: number;
      }

      =======

      export interface IndicatorProps {
        status: Status;
        error: string | null;
        elapsedTime: number;
        onPauseResume: () => void;
      }

      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: src/content/constants.ts
    content: |-
      <<<<<<< SEARCH
        error: {
          bgColor: 'bg-red-500',
          text: 'Error!',
          animate: false,
        },
      };
      =======
        error: {
          bgColor: 'bg-red-500',
          text: 'Error!',
          animate: false,
        },
        paused: {
          bgColor: 'bg-orange-500',
          text: 'Paused',
          animate: false,
        },
      };
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: src/content/Indicator.tsx
    content: >-
      --- src/content/Indicator.tsx

      +++ src/content/Indicator.tsx

      @@ -1,6 +1,6 @@
       import { useRef, useEffect, useState } from 'react';
       import { useDrag } from './useDrag';
       import { statusConfig } from './constants';
      -import type { IndicatorProps, Status } from './types';

      +import type { IndicatorProps } from './types';
       
       function formatElapsedTime(ms: number): string {
         if (ms <= 0) return '00:00';
      @@ -12,7 +12,12 @@
         return `${paddedMinutes}:${paddedSeconds}`;
       }
       
      -function Indicator({ status, error, elapsedTime }: IndicatorProps) {

      +function Indicator({

      +  status,

      +  error,

      +  elapsedTime,

      +  onPauseResume,

      +}: IndicatorProps) {
         const indicatorRef = useRef<HTMLDivElement>(null);
         const { position, handleMouseDown } = useDrag(indicatorRef);
         const [isVisible, setIsVisible] = useState(true);
      @@ -37,6 +42,7 @@
         }
       
         const config = statusConfig[status];
      +  const isPausable = status === 'running' || status === 'paused';
       
         return (
           <div
      @@ -58,21 +64,62 @@
                   }`}
                 ></span>
                 <span className="text-sm font-medium">{config.text}</span>
      -          {status === 'running' && (

      +          {(status === 'running' ||

      +            status === 'paused' ||

      +            status === 'stopped') && (
                   <span className="text-sm font-mono text-gray-300">
                     {formatElapsedTime(elapsedTime)}
                   </span>
                 )}
               </div>
      -        <button

      -          onClick={() => setIsVisible(false)}

      -          className="text-xs text-gray-400 hover:text-white
      cursor-pointer"

      -          title="Hide Indicator"

      -        >

      -          &#x2715;

      -        </button>

      +        <div className="flex items-center">

      +          {isPausable && (

      +            <button

      +              onClick={onPauseResume}

      +              className="text-gray-400 hover:text-white cursor-pointer
      p-1 rounded-full"

      +              title={status === 'running' ? 'Pause' : 'Resume'}

      +            >

      +              {status === 'running' ? (

      +                <svg

      +                  xmlns="http://www.w3.org/2000/svg"

      +                  width="12"

      +                  height="12"

      +                  viewBox="0 0 24 24"

      +                  fill="currentColor"

      +                  className="block"

      +                >

      +                  <path d="M14 19h4V5h-4v14zm-8 0h4V5H6v14z" />

      +                </svg>

      +              ) : (

      +                <svg

      +                  xmlns="http://www.w3.org/2000/svg"

      +                  width="12"

      +                  height="12"

      +                  viewBox="0 0 24 24"

      +                  fill="currentColor"

      +                  className="block"

      +                >

      +                  <path d="M8 5v14l11-7z" />

      +                </svg>

      +              )}

      +            </button>

      +          )}

      +          <button

      +            onClick={() => setIsVisible(false)}

      +            className="text-gray-400 hover:text-white cursor-pointer p-1
      rounded-full"

      +            title="Hide Indicator"

      +          >

      +            <svg

      +              xmlns="http://www.w3.org/2000/svg"

      +              width="12"

      +              height="12"

      +              viewBox="0 0 24 24"

      +              fill="currentColor"

      +              className="block"

      +            >

      +              <path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5
      17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z" />

      +            </svg>

      +          </button>

      +        </div>
             </div>
             {status === 'error' && error && (
               <p className="text-xs text-red-400 px-2 pb-2 -mt-1">{error}</p>
    patchStrategy: new-unified
  - type: write
    path: src/content/App.tsx
    content: |-
      import { useState, useEffect, useCallback, useRef } from 'react';
      import Indicator from './Indicator';
      import type { Status } from './types';

      function App() {
        const [status, setStatus] = useState<Status>('monitoring');
        const [error, setError] = useState<string | null>(null);
        const startTimeRef = useRef<number | null>(null);
        const [elapsedTime, setElapsedTime] = useState(0);
        const pausedTimeRef = useRef(0);
        const pauseStartRef = useRef<number | null>(null);

        useEffect(() => {
          let intervalId: number | undefined;

          if (status === 'running') {
            intervalId = window.setInterval(() => {
              if (startTimeRef.current) {
                const now = Date.now();
                const totalElapsed =
                  now - startTimeRef.current - pausedTimeRef.current;
                setElapsedTime(totalElapsed);
              }
            }, 1000);
          }

          return () => {
            if (intervalId) {
              clearInterval(intervalId);
            }
          };
        }, [status]);

        const handlePauseResume = useCallback(() => {
          setStatus((currentStatus) => {
            if (currentStatus === 'running') {
              // Pausing
              pauseStartRef.current = Date.now();
              // Update elapsed time one last time before pausing interval
              if (startTimeRef.current) {
                setElapsedTime(
                  Date.now() - startTimeRef.current - pausedTimeRef.current
                );
              }
              return 'paused';
            }

            if (currentStatus === 'paused') {
              // Resuming
              if (pauseStartRef.current) {
                pausedTimeRef.current += Date.now() - pauseStartRef.current;
                pauseStartRef.current = null;
              }
              return 'running';
            }

            return currentStatus;
          });
        }, []);

        const checkState = useCallback(() => {
          // When paused, we don't check for state changes.
          if (status === 'paused') return;

          try {
            const stopButtonExists = !!document.querySelector<SVGRectElement>(
              'rect[class*="stoppable-stop"]'
            );

            setStatus((prevStatus) => {
              // Prevent checkState from overriding pause
              if (prevStatus === 'paused') return 'paused';

              const wasRunning = prevStatus === 'running';

              if (wasRunning && !stopButtonExists) {
                // State transition: running -> stopped
                const endTime = Date.now();
                const finalElapsedTime = startTimeRef.current
                  ? endTime - startTimeRef.current - pausedTimeRef.current
                  : 0;
                setElapsedTime(finalElapsedTime < 0 ? 0 : finalElapsedTime);

                console.log(
                  'AI Studio process finished. Playing sound and sending desktop notification.'
                );
                chrome.runtime.sendMessage({
                  type: 'processFinished',
                  durationMs: finalElapsedTime,
                });
                startTimeRef.current = null;
                pausedTimeRef.current = 0;
                pauseStartRef.current = null;
                return 'stopped';
              }

              const newStatus = stopButtonExists ? 'running' : 'monitoring';

              if (newStatus === 'running' && prevStatus !== 'running') {
                // State transition: not running -> running
                startTimeRef.current = Date.now();
                pausedTimeRef.current = 0;
                pauseStartRef.current = null;
                setElapsedTime(0);
              }

              if (
                prevStatus !== newStatus &&
                !(prevStatus === 'stopped' && newStatus === 'monitoring')
              ) {
                console.log(
                  `AI Studio Notifier: State changed to ${
                    stopButtonExists ? 'Running' : 'Monitoring'
                  }`
                );
              }
              // If we were stopped, and a new process hasn't started, stay stopped visually
              // until a new run starts.
              if (prevStatus === 'stopped' && !stopButtonExists) {
                return 'stopped';
              }

              return newStatus;
            });
            setError(null);
          } catch (e) {
            console.error('AI Studio Notifier: Error during state check.', e);
            setError('An error occurred during check.');
            setStatus('error');
          }
        }, [status]);

        useEffect(() => {
          // Initial Check after a short delay
          const timeoutId = setTimeout(checkState, 2000);

          // Observer Setup
          const observer = new MutationObserver(checkState);
          observer.observe(document.body, {
            childList: true,
            subtree: true,
          });
          console.log(
            'AI Studio Notifier: MutationObserver is now watching the page.'
          );

          return () => {
            clearTimeout(timeoutId);
            observer.disconnect();
          };
        }, [checkState]);

        return (
          <Indicator
            status={status}
            error={error}
            elapsedTime={elapsedTime}
            onPauseResume={handlePauseResume}
          />
        );
      }

      export default App;
    patchStrategy: replace
snapshot:
  src/content/types.ts: |-
    export type Status = 'monitoring' | 'running' | 'stopped' | 'error';

    export interface IndicatorProps {
      status: Status;
      error: string | null;
      elapsedTime: number;
    }
  src/content/constants.ts: |-
    import type { Status } from './types';

    export const statusConfig: Record<
      Status,
      { bgColor: string; text: string; animate: boolean }
    > = {
      monitoring: {
        bgColor: 'bg-blue-500',
        text: 'Monitoring',
        animate: false,
      },
      running: {
        bgColor: 'bg-green-500',
        text: 'Process Running',
        animate: true,
      },
      stopped: {
        bgColor: 'bg-yellow-500',
        text: 'Process Finished!',
        animate: false,
      },
      error: {
        bgColor: 'bg-red-500',
        text: 'Error!',
        animate: false,
      },
    };
  src/content/Indicator.tsx: |-
    import { useRef, useEffect, useState } from 'react';
    import { useDrag } from './useDrag';
    import { statusConfig } from './constants';
    import type { IndicatorProps, Status } from './types';

    function formatElapsedTime(ms: number): string {
      if (ms <= 0) return '00:00';
      const totalSeconds = Math.floor(ms / 1000);
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = totalSeconds % 60;
      const paddedMinutes = String(minutes).padStart(2, '0');
      const paddedSeconds = String(seconds).padStart(2, '0');
      return `${paddedMinutes}:${paddedSeconds}`;
    }

    function Indicator({ status, error, elapsedTime }: IndicatorProps) {
      const indicatorRef = useRef<HTMLDivElement>(null);
      const { position, handleMouseDown } = useDrag(indicatorRef);
      const [isVisible, setIsVisible] = useState(true);
      const audioRef = useRef<HTMLAudioElement | null>(null);

      useEffect(() => {
        // Preload audio element when component mounts
        const soundUrl = chrome.runtime.getURL('notification.mp3');
        audioRef.current = new Audio(soundUrl);
      }, []);

      useEffect(() => {
        if (status === 'stopped') {
          audioRef.current
            ?.play()
            .catch((err) => console.error('Audio play failed: ', err));
        }
      }, [status]);

      if (!isVisible) {
        return null;
      }

      const config = statusConfig[status];

      return (
        <div
          ref={indicatorRef}
          className="fixed top-0 left-0 z-[99999] rounded-lg shadow-lg text-white font-sans select-none"
          style={{
            transform: `translate3d(${position.x}px, ${position.y}px, 0)`,
            backgroundColor: 'rgba(20, 20, 20, 0.8)',
            backdropFilter: 'blur(4px)',
          }}
        >
          <div
            className="flex items-center gap-3 p-2 cursor-grab"
            onMouseDown={handleMouseDown}
          >
            <div className="flex items-center gap-2">
              <span
                className={`w-3 h-3 rounded-full ${config.bgColor} ${
                  config.animate ? 'animate-pulse' : ''
                }`}
              ></span>
              <span className="text-sm font-medium">{config.text}</span>
              {status === 'running' && (
                <span className="text-sm font-mono text-gray-300">
                  {formatElapsedTime(elapsedTime)}
                </span>
              )}
            </div>
            <button
              onClick={() => setIsVisible(false)}
              className="text-xs text-gray-400 hover:text-white cursor-pointer"
              title="Hide Indicator"
            >
              &#x2715;
            </button>
          </div>
          {status === 'error' && error && (
            <p className="text-xs text-red-400 px-2 pb-2 -mt-1">{error}</p>
          )}
        </div>
      );
    }

    export default Indicator;
  src/content/App.tsx: |-
    import { useState, useEffect, useCallback, useRef } from 'react';
    import Indicator from './Indicator';
    import type { Status } from './types';

    function App() {
      const [status, setStatus] = useState<Status>('monitoring');
      const [error, setError] = useState<string | null>(null);
      const startTimeRef = useRef<number | null>(null);
      const [elapsedTime, setElapsedTime] = useState(0);

      useEffect(() => {
        let intervalId: number | undefined;

        if (status === 'running' && startTimeRef.current) {
          // Set initial time immediately
          setElapsedTime(Date.now() - startTimeRef.current);

          intervalId = window.setInterval(() => {
            if (startTimeRef.current) {
              setElapsedTime(Date.now() - startTimeRef.current);
            }
          }, 1000);
        } else {
          setElapsedTime(0);
        }

        return () => {
          if (intervalId) {
            clearInterval(intervalId);
          }
        };
      }, [status]);

      const checkState = useCallback(() => {
        try {
          const stopButtonExists = !!document.querySelector<SVGRectElement>(
            'rect[class*="stoppable-stop"]'
          );

          setStatus((prevStatus) => {
            const wasRunning = prevStatus === 'running';
            if (wasRunning && !stopButtonExists) {
              // State transition: running -> stopped
              const endTime = Date.now();
              const durationMs = startTimeRef.current
                ? endTime - startTimeRef.current
                : null;
              console.log(
                'AI Studio process finished. Playing sound and sending desktop notification.'
              );
              chrome.runtime.sendMessage({ type: 'processFinished', durationMs });
              startTimeRef.current = null;
              return 'stopped';
            }

            const newStatus = stopButtonExists ? 'running' : 'monitoring';

            if (newStatus === 'running' && prevStatus !== 'running') {
              // State transition: not running -> running
              startTimeRef.current = Date.now();
            }

            if (
              prevStatus !== newStatus &&
              !(prevStatus === 'stopped' && newStatus === 'monitoring')
            ) {
              console.log(
                `AI Studio Notifier: State changed to ${
                  stopButtonExists ? 'Running' : 'Monitoring'
                }`
              );
            }
            // If we were stopped, and a new process hasn't started, stay stopped visually
            // until a new run starts.
            if (prevStatus === 'stopped' && !stopButtonExists) {
                return 'stopped';
            }

            return newStatus;
          });
          setError(null);
        } catch (e) {
          console.error('AI Studio Notifier: Error during state check.', e);
          setError('An error occurred during check.');
          setStatus('error');
        }
      }, []);

      useEffect(() => {
        // Initial Check after a short delay
        const timeoutId = setTimeout(checkState, 2000);

        // Observer Setup
        const observer = new MutationObserver(checkState);
        observer.observe(document.body, {
          childList: true,
          subtree: true,
        });
        console.log(
          'AI Studio Notifier: MutationObserver is now watching the page.'
        );

        return () => {
          clearTimeout(timeoutId);
          observer.disconnect();
        };
      }, [checkState]);

      return <Indicator status={status} error={error} elapsedTime={elapsedTime} />;
    }

    export default App;
approved: true
