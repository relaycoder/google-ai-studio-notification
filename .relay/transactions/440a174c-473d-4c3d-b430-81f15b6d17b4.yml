uuid: 440a174c-473d-4c3d-b430-81f15b6d17b4
projectId: google-ai-studio-notification
createdAt: '2025-08-05T13:18:35.767Z'
linesAdded: 24
linesRemoved: 14
gitCommitMsg: 'feat: enable pause/resume from monitoring state'
promptSummary: >-
  User requested that the pause/resume functionality should also be available
  during the 'monitoring' state, not just when a process is 'running'. This
  allows pausing the MutationObserver to save resources at any time.
reasoning:
  - >-
    You are absolutely right. The ability to pause should not be limited to when
    a process is actively running. Allowing the user to pause the observer
    during the `monitoring` state is a great way to give them more control and
    save resources.
  - >-
    I will update the logic to allow pausing from the `monitoring` state. Here
    are the steps:
  - >-
    1.  **`src/content/App.tsx`**: I will introduce a `prePauseStatusRef` to
    remember the state (`running` or `monitoring`) before it was paused. This
    ensures that when the user clicks "Resume", the extension returns to the
    correct state. The `handlePauseResume` function will be updated to manage
    these new transitions.
  - >-
    2.  **`src/content/Indicator.tsx`**: I will adjust the UI logic to show the
    pause/resume button when the status is `monitoring`. The button's icon and
    tooltip will also be updated to correctly reflect the possible action (i.e.,
    show a "pause" icon for `monitoring` and `running`, and a "resume" icon for
    `paused`).
  - Here are the code modifications.
  - First, I'll update `App.tsx` with the new pause/resume logic.
  - >-
    Next, I'll update `Indicator.tsx` to display the button correctly in the
    `monitoring` state.
  - >-
    These changes successfully add the ability to pause the extension's observer
    even when no process is running, addressing your feedback perfectly.
operations:
  - type: write
    path: src/content/App.tsx
    content: |-
      <<<<<<< SEARCH
        const [elapsedTime, setElapsedTime] = useState(0);
        const pausedTimeRef = useRef(0);
        const pauseStartRef = useRef<number | null>(null);
      =======
        const [elapsedTime, setElapsedTime] = useState(0);
        const pausedTimeRef = useRef(0);
        const pauseStartRef = useRef<number | null>(null);
        const prePauseStatusRef = useRef<Status>('monitoring');
      >>>>>>> REPLACE
      <<<<<<< SEARCH
        const handlePauseResume = useCallback(() => {
          setStatus((currentStatus) => {
            if (currentStatus === 'running') {
              // Pausing
              pauseStartRef.current = Date.now();
              // Update elapsed time one last time before pausing interval
              if (startTimeRef.current) {
                setElapsedTime(
                  Date.now() - startTimeRef.current - pausedTimeRef.current
                );
              }
              return 'paused';
            }

            if (currentStatus === 'paused') {
              // Resuming
              if (pauseStartRef.current) {
                pausedTimeRef.current += Date.now() - pauseStartRef.current;
                pauseStartRef.current = null;
              }
              return 'running';
            }

            return currentStatus;
          });
        }, []);
      =======
        const handlePauseResume = useCallback(() => {
          setStatus((currentStatus) => {
            if (currentStatus === 'running' || currentStatus === 'monitoring') {
              // Pausing
              prePauseStatusRef.current = currentStatus; // Store where we came from

              if (currentStatus === 'running') {
                pauseStartRef.current = Date.now();
                // Update elapsed time one last time before pausing interval
                if (startTimeRef.current) {
                  setElapsedTime(
                    Date.now() - startTimeRef.current - pausedTimeRef.current
                  );
                }
              }
              return 'paused';
            }

            if (currentStatus === 'paused') {
              // Resuming
              const resumeTo = prePauseStatusRef.current;
              if (resumeTo === 'running') {
                if (pauseStartRef.current) {
                  pausedTimeRef.current += Date.now() - pauseStartRef.current;
                  pauseStartRef.current = null;
                }
              }
              // Resume to the state we were in before pausing
              return resumeTo;
            }

            return currentStatus;
          });
        }, []);
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: src/content/Indicator.tsx
    content: |-
      <<<<<<< SEARCH
        const config = statusConfig[status];
        const isPausable = status === 'running' || status === 'paused';

        return (
      =======
        const config = statusConfig[status];
        const isPausable =
          status === 'running' || status === 'paused' || status === 'monitoring';

        return (
      >>>>>>> REPLACE
      <<<<<<< SEARCH
                {isPausable && (
                  <button
                    onClick={onPauseResume}
                    className="text-gray-400 hover:text-white cursor-pointer p-1 rounded-full"
                    title={status === 'running' ? 'Pause' : 'Resume'}
                  >
                    {status === 'running' ? (
                      <svg
                        xmlns="http://www.w3.org/2000/svg"
                        width="12"
                        height="12"
                        viewBox="0 0 24 24"
                        fill="currentColor"
                        className="block"
                      >
                        <path d="M14 19h4V5h-4v14zm-8 0h4V5H6v14z" />
                      </svg>
                    ) : (
                      <svg
                        xmlns="http://www.w3.org/2000/svg"
                        width="12"
                        height="12"
                        viewBox="0 0 24 24"
                        fill="currentColor"
                        className="block"
                      >
                        <path d="M8 5v14l11-7z" />
                      </svg>
                    )}
                  </button>
                )}
      =======
                {isPausable && (
                  <button
                    onClick={onPauseResume}
                    className="text-gray-400 hover:text-white cursor-pointer p-1 rounded-full"
                    title={status === 'paused' ? 'Resume' : 'Pause'}
                  >
                    {status === 'running' || status === 'monitoring' ? (
                      <svg
                        xmlns="http://www.w3.org/2000/svg"
                        width="12"
                        height="12"
                        viewBox="0 0 24 24"
                        fill="currentColor"
                        className="block"
                      >
                        <path d="M14 19h4V5h-4v14zm-8 0h4V5H6v14z" />
                      </svg>
                    ) : (
                      <svg
                        xmlns="http://www.w3.org/2000/svg"
                        width="12"
                        height="12"
                        viewBox="0 0 24 24"
                        fill="currentColor"
                        className="block"
                      >
                        <path d="M8 5v14l11-7z" />
                      </svg>
                    )}
                  </button>
                )}
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
snapshot:
  src/content/App.tsx: |-
    import { useState, useEffect, useCallback, useRef } from 'react';
    import Indicator from './Indicator';
    import type { Status } from './types';

    function App() {
      const [status, setStatus] = useState<Status>('monitoring');
      const [error, setError] = useState<string | null>(null);
      const startTimeRef = useRef<number | null>(null);
      const [elapsedTime, setElapsedTime] = useState(0);
      const pausedTimeRef = useRef(0);
      const pauseStartRef = useRef<number | null>(null);

      useEffect(() => {
        let intervalId: number | undefined;

        if (status === 'running') {
          intervalId = window.setInterval(() => {
            if (startTimeRef.current) {
              const now = Date.now();
              const totalElapsed =
                now - startTimeRef.current - pausedTimeRef.current;
              setElapsedTime(totalElapsed);
            }
          }, 1000);
        }

        return () => {
          if (intervalId) {
            clearInterval(intervalId);
          }
        };
      }, [status]);

      const handlePauseResume = useCallback(() => {
        setStatus((currentStatus) => {
          if (currentStatus === 'running') {
            // Pausing
            pauseStartRef.current = Date.now();
            // Update elapsed time one last time before pausing interval
            if (startTimeRef.current) {
              setElapsedTime(
                Date.now() - startTimeRef.current - pausedTimeRef.current
              );
            }
            return 'paused';
          }

          if (currentStatus === 'paused') {
            // Resuming
            if (pauseStartRef.current) {
              pausedTimeRef.current += Date.now() - pauseStartRef.current;
              pauseStartRef.current = null;
            }
            return 'running';
          }

          return currentStatus;
        });
      }, []);

      const checkState = useCallback(() => {
        try {
          const stopButtonExists = !!document.querySelector<SVGRectElement>(
            'rect[class*="stoppable-stop"]'
          );

          setStatus((prevStatus) => {
            // Prevent checkState from overriding pause. `prevStatus` is the
            // source of truth from React's state.
            if (prevStatus === 'paused') return 'paused';

            const wasRunning = prevStatus === 'running';

            if (wasRunning && !stopButtonExists) {
              // State transition: running -> stopped
              const endTime = Date.now();
              const finalElapsedTime = startTimeRef.current
                ? endTime - startTimeRef.current - pausedTimeRef.current
                : 0;
              setElapsedTime(finalElapsedTime < 0 ? 0 : finalElapsedTime);

              if (finalElapsedTime >= 3000) {
                console.log(
                  'AI Studio process finished. Sending desktop notification.'
                );
                chrome.runtime.sendMessage({
                  type: 'processFinished',
                  durationMs: finalElapsedTime,
                });
              } else {
                console.log(
                  'AI Studio process finished in under 3 seconds. Skipping desktop notification.'
                );
              }
              startTimeRef.current = null;
              pausedTimeRef.current = 0;
              pauseStartRef.current = null;
              return 'stopped';
            }

            const newStatus = stopButtonExists ? 'running' : 'monitoring';

            if (newStatus === 'running' && prevStatus !== 'running') {
              // State transition: not running -> running
              startTimeRef.current = Date.now();
              pausedTimeRef.current = 0;
              pauseStartRef.current = null;
              setElapsedTime(0);
            }

            if (
              prevStatus !== newStatus &&
              !(prevStatus === 'stopped' && newStatus === 'monitoring')
            ) {
              console.log(
                `AI Studio Notifier: State changed to ${
                  stopButtonExists ? 'Running' : 'Monitoring'
                }`
              );
            }
            // If we were stopped, and a new process hasn't started, stay stopped visually
            // until a new run starts.
            if (prevStatus === 'stopped' && !stopButtonExists) {
              return 'stopped';
            }

            return newStatus;
          });
          setError(null);
        } catch (e) {
          console.error('AI Studio Notifier: Error during state check.', e);
          setError('An error occurred during check.');
          setStatus('error');
        }
      }, []);

      useEffect(() => {
        // When paused, the observer should not be active to save resources.
        if (status === 'paused') {
          // The cleanup function of the previous effect run has already disconnected
          // the observer. We don't set up a new one while paused.
          return;
        }

        // Initial Check after a short delay
        const timeoutId = setTimeout(checkState, 2000);

        // Observer Setup
        const observer = new MutationObserver(checkState);
        observer.observe(document.body, {
          childList: true,
          subtree: true,
        });
        console.log(
          'AI Studio Notifier: MutationObserver is now watching the page.'
        );

        return () => {
          clearTimeout(timeoutId);
          observer.disconnect();
          console.log('AI Studio Notifier: MutationObserver disconnected.');
        };
      }, [checkState, status]);

      return (
        <Indicator
          status={status}
          error={error}
          elapsedTime={elapsedTime}
          onPauseResume={handlePauseResume}
        />
      );
    }

    export default App;
  src/content/Indicator.tsx: |-
    import { useRef, useEffect, useState } from 'react';
    import { useDrag } from './useDrag';
    import { statusConfig } from './constants';
    import type { IndicatorProps } from './types';

    function formatElapsedTime(ms: number): string {
      if (ms <= 0) return '00:00';
      const totalSeconds = Math.floor(ms / 1000);
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = totalSeconds % 60;
      const paddedMinutes = String(minutes).padStart(2, '0');
      const paddedSeconds = String(seconds).padStart(2, '0');
      return `${paddedMinutes}:${paddedSeconds}`;
    }

    function Indicator({
      status,
      error,
      elapsedTime,
      onPauseResume,
    }: IndicatorProps) {
      const indicatorRef = useRef<HTMLDivElement>(null);
      const { position, handleMouseDown } = useDrag(indicatorRef);
      const [isVisible, setIsVisible] = useState(true);
      const audioRef = useRef<HTMLAudioElement | null>(null);

      useEffect(() => {
        // Preload audio element when component mounts
        const soundUrl = chrome.runtime.getURL('notification.mp3');
        audioRef.current = new Audio(soundUrl);
      }, []);

      useEffect(() => {
        if (status === 'stopped') {
          audioRef.current
            ?.play()
            .catch((err) => console.error('Audio play failed: ', err));
        }
      }, [status]);

      if (!isVisible) {
        return null;
      }

      const config = statusConfig[status];
      const isPausable = status === 'running' || status === 'paused';

      return (
        <div
          ref={indicatorRef}
          className="fixed top-0 left-0 z-[99999] rounded-lg shadow-lg text-white font-sans select-none"
          style={{
            transform: `translate3d(${position.x}px, ${position.y}px, 0)`,
            backgroundColor: 'rgba(20, 20, 20, 0.8)',
            backdropFilter: 'blur(4px)',
          }}
        >
          <div
            className="flex items-center gap-3 p-2 cursor-grab"
            onMouseDown={handleMouseDown}
          >
            <div className="flex items-center gap-2">
              <span
                className={`w-3 h-3 rounded-full ${config.bgColor} ${
                  config.animate ? 'animate-pulse' : ''
                }`}
              ></span>
              <span className="text-sm font-medium">{config.text}</span>
              {(status === 'running' ||
                status === 'paused' ||
                status === 'stopped') && (
                <span className="text-sm font-mono text-gray-300">
                  {formatElapsedTime(elapsedTime)}
                </span>
              )}
            </div>
            <div className="flex items-center">
              {isPausable && (
                <button
                  onClick={onPauseResume}
                  className="text-gray-400 hover:text-white cursor-pointer p-1 rounded-full"
                  title={status === 'running' ? 'Pause' : 'Resume'}
                >
                  {status === 'running' ? (
                    <svg
                      xmlns="http://www.w3.org/2000/svg"
                      width="12"
                      height="12"
                      viewBox="0 0 24 24"
                      fill="currentColor"
                      className="block"
                    >
                      <path d="M14 19h4V5h-4v14zm-8 0h4V5H6v14z" />
                    </svg>
                  ) : (
                    <svg
                      xmlns="http://www.w3.org/2000/svg"
                      width="12"
                      height="12"
                      viewBox="0 0 24 24"
                      fill="currentColor"
                      className="block"
                    >
                      <path d="M8 5v14l11-7z" />
                    </svg>
                  )}
                </button>
              )}
              <button
                onClick={() => setIsVisible(false)}
                className="text-gray-400 hover:text-white cursor-pointer p-1 rounded-full"
                title="Hide Indicator"
              >
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  width="12"
                  height="12"
                  viewBox="0 0 24 24"
                  fill="currentColor"
                  className="block"
                >
                  <path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z" />
                </svg>
              </button>
            </div>
          </div>
          {status === 'error' && error && (
            <p className="text-xs text-red-400 px-2 pb-2 -mt-1">{error}</p>
          )}
        </div>
      );
    }

    export default Indicator;
approved: true
