uuid: 4f107018-05b1-490b-8526-a05d8f6cc971
projectId: google-ai-studio-notification
createdAt: '2025-08-06T21:06:52.698Z'
linesAdded: 4
linesRemoved: 3
gitCommitMsg: 'refactor: centralize stop button selector in constants'
promptSummary: Move the hardcoded stop button selector from App.tsx to constants.ts.
reasoning:
  - >-
    I've identified that the UI selector for the "stop button" is hardcoded in
    `App.tsx`. To improve maintainability and centralize constants, I will move
    this selector into `src/content/constants.ts`.
  - >-
    First, I'll add the selector as a new constant in
    `src/content/constants.ts`.
  - >-
    Next, I'll update `src/content/App.tsx` to import and use this new constant.
    This involves adding an import statement and replacing the hardcoded string
    in the `checkState` function.
operations:
  - type: write
    path: src/content/constants.ts
    content: |-
      <<<<<<< SEARCH
      import type { Status, ConnectionStatus } from '../types';

      export const statusConfig: Record<
      =======
      import type { Status, ConnectionStatus } from '../types';

      export const STOP_BUTTON_SELECTOR = 'rect[class*="stoppable-stop"]';

      export const statusConfig: Record<
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: src/content/App.tsx
    content: |-
      <<<<<<< SEARCH
      import { useState, useEffect, useCallback, useRef } from 'react';
      import Indicator from './Indicator';
      import type { GlobalState, ConnectionStatus } from '../types';
      =======
      import { useState, useEffect, useCallback, useRef } from 'react';
      import Indicator from './Indicator';
      import { STOP_BUTTON_SELECTOR } from './constants';
      import type { GlobalState, ConnectionStatus } from '../types';
      >>>>>>> REPLACE
      <<<<<<< SEARCH
          try {
            const stopButtonExists = !!document.querySelector<SVGRectElement>(
              'rect[class*="stoppable-stop"]'
            );
            if (stopButtonExists !== lastKnownStopButtonState.current) {
      =======
          try {
            const stopButtonExists = !!document.querySelector(STOP_BUTTON_SELECTOR);
            if (stopButtonExists !== lastKnownStopButtonState.current) {
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
snapshot:
  src/content/constants.ts: |-
    import type { Status, ConnectionStatus } from '../types';

    export const statusConfig: Record<
      Status,
      { bgColor: string; text: string; animate: boolean }
    > = {
      monitoring: {
        bgColor: 'bg-blue-500',
        text: 'Monitoring',
        animate: false,
      },
      running: {
        bgColor: 'bg-green-500',
        text: 'Process Running',
        animate: true,
      },
      stopped: {
        bgColor: 'bg-yellow-500',
        text: 'Process Finished!',
        animate: false,
      },
      error: {
        bgColor: 'bg-red-500',
        text: 'Error!',
        animate: false,
      },
      paused: {
        bgColor: 'bg-orange-500',
        text: 'Paused',
        animate: false,
      },
      standby: {
        bgColor: 'bg-gray-500',
        text: 'Standby',
        animate: false,
      },
    };

    export const connectionStatusConfig: Record<
      ConnectionStatus,
      { bgColor: string; text: string; animate: boolean }
    > = {
      connecting: {
        bgColor: 'bg-yellow-500',
        text: 'Connecting...',
        animate: true,
      },
      connected: {
        // This is a placeholder, as 'connected' status will use the run status config.
        bgColor: '',
        text: '',
        animate: false,
      },
      disconnected: {
        bgColor: 'bg-orange-500',
        text: 'Disconnected. Reconnecting...',
        animate: true,
      },
      invalidated: {
        bgColor: 'bg-red-500',
        text: 'Error: Please reload tab',
        animate: false,
      },
    };
  src/content/App.tsx: |-
    import { useState, useEffect, useCallback, useRef } from 'react';
    import Indicator from './Indicator';
    import type { GlobalState, ConnectionStatus } from '../types';

    /**
     * Captures the current tab's title to use as the run name.
     * This makes notifications more informative.
     * @returns The tab's title, or null if it's empty.
     */
    function captureRunContext(): string | null {
      try {
        const title = document.title?.trim();
        if (title) {
          // Clean up the title, e.g., remove " - Google AI Studio"
          return title.replace(/ - Google AI Studio$/, '').trim();
        }
      } catch (e) {
        console.error(
          'AI Studio Notifier: Error capturing run context from tab title.',
          e
        );
      }
      return null;
    }

    function App() {
      const [tabId, setTabId] = useState<number | null>(null);
      const [globalState, setGlobalState] = useState<GlobalState>({});
      const [connectionStatus, setConnectionStatus] =
        useState<ConnectionStatus>('connecting');
      const lastKnownStopButtonState = useRef<boolean>(false);
      const portRef = useRef<chrome.runtime.Port | null>(null);

      useEffect(() => {
        let port: chrome.runtime.Port | null = null;
        let isInvalidated = false;
        let reconnectTimeoutId: number | undefined;

        function connect() {
          // Don't try to connect if the context is known to be invalid
          if (isInvalidated) return;
          setConnectionStatus('connecting');

          try {
            // Accessing chrome.runtime.id will throw if context is invalidated
            if (!chrome.runtime?.id) {
              isInvalidated = true;
              setConnectionStatus('invalidated');
              console.error(
                'AI Studio Notifier: Extension context invalidated. Cannot connect.'
              );
              return;
            }

            port = chrome.runtime.connect({ name: 'content-script' });
            portRef.current = port;

            port.onMessage.addListener((message: any) => {
              setConnectionStatus('connected');
              if (message.type === 'init') {
                setTabId(message.tabId);
                setGlobalState(message.state);
              } else if (message.type === 'stateUpdate') {
                setGlobalState(message.state);
              }
            });

            port.onDisconnect.addListener(() => {
              portRef.current = null;
              port = null;
              // If the disconnect was not from an invalidated context, try to reconnect.
              if (chrome.runtime?.id) {
                setConnectionStatus('disconnected');
                console.log(
                  'AI Studio Notifier: Port disconnected. Reconnecting in 1s...'
                );
                if (reconnectTimeoutId) clearTimeout(reconnectTimeoutId);
                reconnectTimeoutId = setTimeout(connect, 1000);
              } else {
                setConnectionStatus('invalidated');
                console.error(
                  'AI Studio Notifier: Port disconnected due to invalidated context.'
                );
                isInvalidated = true;
              }
            });
          } catch (e) {
            portRef.current = null;
            port = null;
            console.error(
              'AI Studio Notifier: Connection to background script failed:',
              e
            );
            if (e instanceof Error && e.message.includes('context invalidated')) {
              isInvalidated = true;
              setConnectionStatus('invalidated');
            } else {
              setConnectionStatus('disconnected');
              // Retry connection after a delay if it's not a fatal error
              if (reconnectTimeoutId) clearTimeout(reconnectTimeoutId);
              reconnectTimeoutId = setTimeout(connect, 5000);
            }
          }
        }

        connect();

        return () => {
          if (reconnectTimeoutId) {
            clearTimeout(reconnectTimeoutId);
          }
          // The port object might be from a previous connect attempt, so check it
          if (port) {
            port.disconnect();
          }
          portRef.current = null;
        };
      }, []); // This effect runs only once on component mount

      const postMessage = useCallback((message: any) => {
        if (!portRef.current) {
          console.error(
            'AI Studio Notifier: Cannot post message, port is not connected. It may be sent after reconnection.'
          );
          return;
        }

        try {
          portRef.current.postMessage(message);
        } catch (e) {
          console.warn(
            'AI Studio Notifier: Could not post message. The port was likely disconnected just now.',
            e
          );
          // The onDisconnect listener will handle reconnection.
        }
      }, []);

      const checkState = useCallback(() => {
        if (!tabId) return;
        const currentTabState = globalState[tabId];
        if (
          !currentTabState ||
          currentTabState.status === 'paused' ||
          currentTabState.status === 'standby'
        ) {
          return;
        }

        try {
          const stopButtonExists = !!document.querySelector<SVGRectElement>(
            'rect[class*="stoppable-stop"]'
          );
          if (stopButtonExists !== lastKnownStopButtonState.current) {
            lastKnownStopButtonState.current = stopButtonExists;
            if (stopButtonExists) {
              postMessage({ type: 'startRun', runName: captureRunContext() });
            } else {
              postMessage({ type: 'stopRun' });
            }
          }
        } catch (e) {
          console.error('AI Studio Notifier: Error during state check.', e);
          postMessage({ type: 'error', error: 'An error occurred during check.' });
        }
      }, [globalState, tabId, postMessage]);

      useEffect(() => {
        if (!tabId) return;
        const currentTabState = globalState[tabId];
        if (
          currentTabState?.status === 'paused' ||
          currentTabState?.status === 'standby'
        ) {
          return;
        }

        const timeoutId = setTimeout(checkState, 1000);
        const observer = new MutationObserver(checkState);
        observer.observe(document.body, { childList: true, subtree: true });

        return () => {
          clearTimeout(timeoutId);
          observer.disconnect();
        };
      }, [checkState, tabId, globalState]);

      const handlePauseResume = useCallback(
        () => postMessage({ type: 'pauseResume' }),
        [postMessage]
      );
      const handleClose = useCallback(
        () => postMessage({ type: 'closeIndicator' }),
        [postMessage]
      );
      const handleNavigate = useCallback(
        (navTabId: number, windowId: number) => {
          postMessage({ type: 'navigateToTab', tabId: navTabId, windowId });
        },
        [postMessage]
      );

      if (!tabId || !globalState[tabId]?.isVisible) {
        return null;
      }

      const currentTabState = globalState[tabId];
      if (!currentTabState) return null; // Should not happen if tabId is set

      return (
        <Indicator
          currentTabState={currentTabState}
          allTabsState={globalState}
          connectionStatus={connectionStatus}
          onPauseResume={handlePauseResume}
          onClose={handleClose}
          onNavigate={handleNavigate}
        />
      );
    }

    export default App;
approved: true
