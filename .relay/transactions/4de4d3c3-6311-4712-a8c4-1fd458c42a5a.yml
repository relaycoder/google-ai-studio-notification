uuid: 4de4d3c3-6311-4712-a8c4-1fd458c42a5a
projectId: google-ai-studio-notification
createdAt: '2025-08-05T12:59:04.423Z'
linesAdded: 43
linesRemoved: 37
gitCommitMsg: 'refactor: extract types and constants into separate files'
promptSummary: >-
  The user wants to move all constants to a `constants.ts` file and all types to
  a `types.ts` file.
reasoning:
  - >-
    Of course! I can help you refactor your code by moving constants and types
    into their own dedicated files. This is a great practice for improving code
    organization and maintainability. Here are the necessary changes:
  - >-
    First, I'll create a new file, `src/content/types.ts`, to hold the type
    definitions that are shared within your content scripts.
  - >-
    Next, I'll create `src/content/constants.ts` for the `statusConfig` object,
    which is a constant used in the UI.
  - >-
    I'll also create a new `src/types.ts` file for the `NotificationContext`
    type used by the background script.
  - >-
    Now, I'll update `App.tsx` to remove the inline `Status` type and import it
    from the new `types.ts` file.
  - >-
    I'll update `Indicator.tsx` to import the types and constants from their new
    files, removing the local definitions.
  - >-
    Finally, I'll modify `background.ts` to import the `NotificationContext`
    type.
  - >-
    These changes should successfully refactor your code as requested. Let me
    know if you have any other questions!
operations:
  - type: write
    path: src/content/types.ts
    content: |-
      export type Status = 'monitoring' | 'running' | 'stopped' | 'error';

      export interface IndicatorProps {
        status: Status;
        error: string | null;
        elapsedTime: number;
      }
    patchStrategy: replace
  - type: write
    path: src/content/constants.ts
    content: |-
      import type { Status } from './types';

      export const statusConfig: Record<
        Status,
        { bgColor: string; text: string; animate: boolean }
      > = {
        monitoring: {
          bgColor: 'bg-blue-500',
          text: 'Monitoring',
          animate: false,
        },
        running: {
          bgColor: 'bg-green-500',
          text: 'Process Running',
          animate: true,
        },
        stopped: {
          bgColor: 'bg-yellow-500',
          text: 'Process Finished!',
          animate: false,
        },
        error: {
          bgColor: 'bg-red-500',
          text: 'Error!',
          animate: false,
        },
      };
    patchStrategy: replace
  - type: write
    path: src/types.ts
    content: |-
      export interface NotificationContext {
        tabId: number;
        windowId: number;
        durationMs?: number | null;
      }
    patchStrategy: replace
  - type: write
    path: src/content/App.tsx
    content: |-
      <<<<<<< SEARCH
      import { useState, useEffect, useCallback, useRef } from 'react';
      import Indicator from './Indicator';

      export type Status = 'monitoring' | 'running' | 'stopped' | 'error';

      function App() {
      =======
      import { useState, useEffect, useCallback, useRef } from 'react';
      import Indicator from './Indicator';
      import type { Status } from './types';

      function App() {
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: src/content/Indicator.tsx
    content: >-
      <<<<<<< SEARCH

      import { useRef, useEffect, useState } from 'react';

      import { useDrag } from './useDrag';

      import type { Status } from './App';


      interface IndicatorProps {
        status: Status;
        error: string | null;
        elapsedTime: number;
      }


      const statusConfig: Record<Status, { bgColor: string; text: string;
      animate: boolean }> = {
        monitoring: {
          bgColor: 'bg-blue-500',
          text: 'Monitoring',
          animate: false,
        },
        running: {
          bgColor: 'bg-green-500',
          text: 'Process Running',
          animate: true,
        },
        stopped: {
          bgColor: 'bg-yellow-500',
          text: 'Process Finished!',
          animate: false,
        },
        error: {
          bgColor: 'bg-red-500',
          text: 'Error!',
          animate: false,
        },
      };

      =======

      import { useRef, useEffect, useState } from 'react';

      import { useDrag } from './useDrag';

      import { statusConfig } from './constants';

      import type { IndicatorProps, Status } from './types';

      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: src/background.ts
    content: |-
      <<<<<<< SEARCH
      interface NotificationContext {
        tabId: number;
        windowId: number;
        durationMs?: number | null;
      }

      // Context for notifications is stored in chrome.storage.local to survive
      =======
      import type { NotificationContext } from './types';

      // Context for notifications is stored in chrome.storage.local to survive
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
snapshot:
  src/content/types.ts: null
  src/content/constants.ts: null
  src/types.ts: null
  src/content/App.tsx: |-
    import { useState, useEffect, useCallback, useRef } from 'react';
    import Indicator from './Indicator';

    export type Status = 'monitoring' | 'running' | 'stopped' | 'error';

    function App() {
      const [status, setStatus] = useState<Status>('monitoring');
      const [error, setError] = useState<string | null>(null);
      const startTimeRef = useRef<number | null>(null);
      const [elapsedTime, setElapsedTime] = useState(0);

      useEffect(() => {
        let intervalId: number | undefined;

        if (status === 'running' && startTimeRef.current) {
          // Set initial time immediately
          setElapsedTime(Date.now() - startTimeRef.current);

          intervalId = window.setInterval(() => {
            if (startTimeRef.current) {
              setElapsedTime(Date.now() - startTimeRef.current);
            }
          }, 1000);
        } else {
          setElapsedTime(0);
        }

        return () => {
          if (intervalId) {
            clearInterval(intervalId);
          }
        };
      }, [status]);

      const checkState = useCallback(() => {
        try {
          const stopButtonExists = !!document.querySelector<SVGRectElement>(
            'rect[class*="stoppable-stop"]'
          );

          setStatus((prevStatus) => {
            const wasRunning = prevStatus === 'running';
            if (wasRunning && !stopButtonExists) {
              // State transition: running -> stopped
              const endTime = Date.now();
              const durationMs = startTimeRef.current
                ? endTime - startTimeRef.current
                : null;
              console.log(
                'AI Studio process finished. Playing sound and sending desktop notification.'
              );
              chrome.runtime.sendMessage({ type: 'processFinished', durationMs });
              startTimeRef.current = null;
              return 'stopped';
            }

            const newStatus = stopButtonExists ? 'running' : 'monitoring';

            if (newStatus === 'running' && prevStatus !== 'running') {
              // State transition: not running -> running
              startTimeRef.current = Date.now();
            }

            if (
              prevStatus !== newStatus &&
              !(prevStatus === 'stopped' && newStatus === 'monitoring')
            ) {
              console.log(
                `AI Studio Notifier: State changed to ${
                  stopButtonExists ? 'Running' : 'Monitoring'
                }`
              );
            }
            // If we were stopped, and a new process hasn't started, stay stopped visually
            // until a new run starts.
            if (prevStatus === 'stopped' && !stopButtonExists) {
                return 'stopped';
            }

            return newStatus;
          });
          setError(null);
        } catch (e) {
          console.error('AI Studio Notifier: Error during state check.', e);
          setError('An error occurred during check.');
          setStatus('error');
        }
      }, []);

      useEffect(() => {
        // Initial Check after a short delay
        const timeoutId = setTimeout(checkState, 2000);

        // Observer Setup
        const observer = new MutationObserver(checkState);
        observer.observe(document.body, {
          childList: true,
          subtree: true,
        });
        console.log(
          'AI Studio Notifier: MutationObserver is now watching the page.'
        );

        return () => {
          clearTimeout(timeoutId);
          observer.disconnect();
        };
      }, [checkState]);

      return <Indicator status={status} error={error} elapsedTime={elapsedTime} />;
    }

    export default App;
  src/content/Indicator.tsx: >-
    import { useRef, useEffect, useState } from 'react';

    import { useDrag } from './useDrag';

    import type { Status } from './App';


    interface IndicatorProps {
      status: Status;
      error: string | null;
      elapsedTime: number;
    }


    const statusConfig: Record<Status, { bgColor: string; text: string; animate:
    boolean }> = {
      monitoring: {
        bgColor: 'bg-blue-500',
        text: 'Monitoring',
        animate: false,
      },
      running: {
        bgColor: 'bg-green-500',
        text: 'Process Running',
        animate: true,
      },
      stopped: {
        bgColor: 'bg-yellow-500',
        text: 'Process Finished!',
        animate: false,
      },
      error: {
        bgColor: 'bg-red-500',
        text: 'Error!',
        animate: false,
      },
    };


    function formatElapsedTime(ms: number): string {
      if (ms <= 0) return '00:00';
      const totalSeconds = Math.floor(ms / 1000);
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = totalSeconds % 60;
      const paddedMinutes = String(minutes).padStart(2, '0');
      const paddedSeconds = String(seconds).padStart(2, '0');
      return `${paddedMinutes}:${paddedSeconds}`;
    }


    function Indicator({ status, error, elapsedTime }: IndicatorProps) {
      const indicatorRef = useRef<HTMLDivElement>(null);
      const { position, handleMouseDown } = useDrag(indicatorRef);
      const [isVisible, setIsVisible] = useState(true);
      const audioRef = useRef<HTMLAudioElement | null>(null);

      useEffect(() => {
        // Preload audio element when component mounts
        const soundUrl = chrome.runtime.getURL('notification.mp3');
        audioRef.current = new Audio(soundUrl);
      }, []);

      useEffect(() => {
        if (status === 'stopped') {
          audioRef.current
            ?.play()
            .catch((err) => console.error('Audio play failed: ', err));
        }
      }, [status]);

      if (!isVisible) {
        return null;
      }

      const config = statusConfig[status];

      return (
        <div
          ref={indicatorRef}
          className="fixed top-0 left-0 z-[99999] rounded-lg shadow-lg text-white font-sans select-none"
          style={{
            transform: `translate3d(${position.x}px, ${position.y}px, 0)`,
            backgroundColor: 'rgba(20, 20, 20, 0.8)',
            backdropFilter: 'blur(4px)',
          }}
        >
          <div
            className="flex items-center gap-3 p-2 cursor-grab"
            onMouseDown={handleMouseDown}
          >
            <div className="flex items-center gap-2">
              <span
                className={`w-3 h-3 rounded-full ${config.bgColor} ${
                  config.animate ? 'animate-pulse' : ''
                }`}
              ></span>
              <span className="text-sm font-medium">{config.text}</span>
              {status === 'running' && (
                <span className="text-sm font-mono text-gray-300">
                  {formatElapsedTime(elapsedTime)}
                </span>
              )}
            </div>
            <button
              onClick={() => setIsVisible(false)}
              className="text-xs text-gray-400 hover:text-white cursor-pointer"
              title="Hide Indicator"
            >
              &#x2715;
            </button>
          </div>
          {status === 'error' && error && (
            <p className="text-xs text-red-400 px-2 pb-2 -mt-1">{error}</p>
          )}
        </div>
      );
    }


    export default Indicator;
  src/background.ts: |-
    interface NotificationContext {
      tabId: number;
      windowId: number;
      durationMs?: number | null;
    }

    // Context for notifications is stored in chrome.storage.local to survive
    // service worker termination. A `notification:` prefix is used for the key.

    function formatDuration(ms: number | null | undefined): string {
      if (!ms || ms < 500) {
        return '';
      }

      // Round to nearest second
      const totalSeconds = Math.round(ms / 1000);

      if (totalSeconds < 1) {
        return '';
      }

      if (totalSeconds < 60) {
        return `in ${totalSeconds}s`;
      }

      const minutes = Math.floor(totalSeconds / 60);
      const seconds = totalSeconds % 60;

      if (seconds === 0) {
        return `in ${minutes}m`;
      }

      return `in ${minutes}m ${seconds}s`;
    }

    /**
     * Creates and displays a desktop notification.
     * @param context - The context containing the tab and window IDs.
     */
    function createNotification(context: NotificationContext) {
      const durationString = formatDuration(context.durationMs);
      const message = `Your process has finished!${
        durationString ? ` ${durationString}` : ''
      }`;
      // The notificationId is guaranteed to be unique for the session.
      chrome.notifications.create(
        {
          type: 'basic',
          iconUrl: 'icon128.png',
          title: 'AI Studio',
          message: message,
          priority: 2,
          // `requireInteraction: false` is the default. It means the notification
          // will auto-dismiss after a short time. On some OSes (like Windows),
          // notifications with buttons may persist in an action center regardless.
          requireInteraction: false,
          buttons: [
            { title: 'Go To Tab' },
            { title: 'Dismiss' },
            { title: 'Remind 5 in' },
          ],
        },
        (notificationId) => {
          if (notificationId) {
            const storageKey = `notification:${notificationId}`;
            chrome.storage.local.set({ [storageKey]: context });
            console.log(
              `Notification created: ${notificationId}. Context stored.`
            );
          }
        }
      );
    }

    // Listen for messages from the content script
    chrome.runtime.onMessage.addListener((message, sender) => {
      if (message.type === 'processFinished') {
        console.log('Background script received processFinished message.');

        if (sender.tab?.id && sender.tab?.windowId) {
          const context: NotificationContext = {
            tabId: sender.tab.id,
            windowId: sender.tab.windowId,
            durationMs: message.durationMs,
          };
          createNotification(context);
        } else {
          console.error(
            'Could not create notification: sender tab details are missing.'
          );
        }
      }
    });

    // Listener for when a user clicks a button on the notification
    chrome.notifications.onButtonClicked.addListener(
      async (notificationId, buttonIndex) => {
        const storageKey = `notification:${notificationId}`;
        const data = await chrome.storage.local.get(storageKey);
        const context = data[storageKey] as NotificationContext | undefined;

        if (!context) {
          console.warn(`No context found for notification: ${notificationId}`);
          return;
        }

        switch (buttonIndex) {
          case 0: // Go To Tab
            chrome.windows.update(context.windowId, { focused: true });
            chrome.tabs.update(context.tabId, { active: true });
            // Clearing the notification will trigger the onClosed listener for cleanup
            chrome.notifications.clear(notificationId);
            break;
          case 1: // Dismiss
            chrome.notifications.clear(notificationId);
            break;
          case 2: // Remind 5 min 5 min
            {
              const alarmName = `remind-${notificationId}`;
              // Store context for when the alarm fires
              await chrome.storage.local.set({ [alarmName]: context });
              chrome.alarms.create(alarmName, { delayInMinutes: 5 });
              // Clearing the notification will also trigger onClosed, which cleans
              // up the original `notification:<id>` storage.
              chrome.notifications.clear(notificationId);
            }
            break;
        }
      }
    );

    // Listener for when a notification is closed (programmatically or by user)
    // This is crucial for cleaning up storage to prevent exceeding quotas.
    chrome.notifications.onClosed.addListener((notificationId) => {
      const storageKey = `notification:${notificationId}`;
      // We don't need to await this, it can run in the background.
      chrome.storage.local.remove(storageKey);
      console.log(
        `Cleaned up storage for closed notification: ${notificationId}`
      );
    });

    // Listener for alarms (for the "Remind" feature)
    chrome.alarms.onAlarm.addListener(async (alarm) => {
      if (alarm.name.startsWith('remind-')) {
        const data = await chrome.storage.local.get(alarm.name);
        const context = data[alarm.name] as NotificationContext | undefined;

        if (context) {
          console.log(`Re-creating notification from alarm: ${alarm.name}`);
          createNotification(context);
          // Clean up the storage
          await chrome.storage.local.remove(alarm.name);
        }
      }
    });
approved: true
