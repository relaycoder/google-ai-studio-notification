uuid: 489c62ea-f4d0-474c-8186-b4b1a13e2f52
projectId: google-ai-studio-notification
createdAt: '2025-08-05T13:58:36.191Z'
linesAdded: 621
linesRemoved: 238
gitCommitMsg: 'feat: add expandable multi-tab run history'
promptSummary: >-
  The user requested a significant feature enhancement: an expandable run
  history view in the indicator. This history should be session-based, track
  runs from all open AI Studio tabs, and provide details like run name,
  duration, and status. It also required summary statistics like average run
  time and the ability to click on a history item to navigate to the
  corresponding tab. This necessitated a major architectural refactor to a
  centralized state model managed by the background script.
reasoning:
  - >-
    This is a significant feature update that introduces a centralized state
    management system in the background script to track runs across multiple
    tabs. This enables a new, expandable run history view in the indicator UI.
  - 'Here is a summary of the changes:'
  - '1.  **Centralized State (`background.ts`)**:'
  - >-
    *   The background script now manages the state for all tracked tabs (e.g.,
    status, run time, history) in `chrome.storage.local`.
  - >-
    *   It uses long-lived port-based connections (`chrome.runtime.connect`) for
    robust communication with content scripts.
  - >-
    *   It handles all state transitions, timer updates for running processes,
    and history aggregation.
  - '2.  **New Global Types (`src/types.ts`)**:'
  - >-
    *   A new `src/types.ts` file is created to define shared data structures
    for the global state, tab state, run history entries, and communication
    messages.
  - >-
    *   The old `src/content/types.ts` is removed and its types are merged into
    the new central file.
  - '3.  **Refactored Content Script (`src/content/App.tsx`)**:'
  - '*   The main React component is simplified to be a "dumb" view controller.'
  - >-
    *   It establishes a connection with the background script to receive state
    updates and send events (e.g., run start/stop detected in the DOM, UI
    interactions).
  - >-
    *   It no longer manages its own state, relying on the global state provided
    by the background script.
  - '4.  **Enhanced Indicator UI (`src/content/Indicator.tsx`)**:'
  - '*   The indicator is now expandable via a new dropdown button.'
  - '*   When expanded, it displays a **Run History** view.'
  - >-
    *   This view lists all tabs that have completed runs, showing each run's
    status (success/error), name, and duration.
  - >-
    *   Clicking on a tab or a run in the history will navigate the user to that
    specific tab.
  - >-
    *   A summary statistic showing the average run duration for the session is
    also included.
  - >-
    This refactoring creates a more scalable and robust architecture for the
    extension, allowing for new cross-tab features like the run history.
  - I will now create the new `src/types.ts` file.
  - Next, I will delete `src/content/types.ts`.
  - Now, I'll update `background.ts` to be the central state manager.
  - Now I will refactor `App.tsx` to work with the new background script.
  - Finally, I'll update `Indicator.tsx` to include the new history UI.
operations:
  - type: write
    path: src/types.ts
    content: >-
      export type Status = 'monitoring' | 'running' | 'stopped' | 'error' |
      'paused';


      export interface RunHistoryEntry {
        id: string;
        runName: string | null;
        durationMs: number;
        status: 'stopped' | 'error';
        endTime: number;
      }


      export interface TabState {
        tabId: number;
        windowId: number;
        status: Status;
        runName: string | null;
        startTime: number | null;
        elapsedTime: number;
        pausedTime: number;
        pauseStartTime: number | null;
        history: RunHistoryEntry[];
        error: string | null;
        isVisible: boolean; // To control indicator visibility per tab
      }


      export interface GlobalState {
        [tabId: number]: TabState;
      }


      export interface MessageBase {
        type: string;
      }


      export interface InitMessage extends MessageBase {
          type: 'init';
          tabId: number;
          state: GlobalState;
      }


      export interface StateUpdateMessage extends MessageBase {
          type: 'stateUpdate';
          state: GlobalState;
      }


      export interface StartRunMessage extends MessageBase {
          type: 'startRun';
          runName: string | null;
      }


      export interface StopRunMessage extends MessageBase {
          type: 'stopRun';
          isError?: boolean;
          error?: string;
      }


      export interface PauseResumeMessage extends MessageBase {
          type: 'pauseResume';
      }


      export interface CloseIndicatorMessage extends MessageBase {
          type: 'closeIndicator';
      }


      export interface NavigateToTabMessage extends MessageBase {
          type: 'navigateToTab';
          tabId: number;
          windowId: number;
      }


      export interface ErrorMessage extends MessageBase {
          type: 'error';
          error: string;
      }



      // Union type for messages

      export type Message =
        | InitMessage
        | StateUpdateMessage
        | StartRunMessage
        | StopRunMessage
        | PauseResumeMessage
        | CloseIndicatorMessage
        | NavigateToTabMessage
        | ErrorMessage;


      export interface NotificationContext {
        tabId: number;
        windowId: number;
        durationMs?: number | null;
        runName?: string | null;
      }


      export interface IndicatorProps {
        currentTabState: TabState;
        allTabsState: GlobalState;
        onPauseResume: () => void;
        onClose: () => void;
        onNavigate: (tabId: number, windowId: number) => void;
      }
    patchStrategy: replace
  - type: delete
    path: src/content/types.ts
  - type: write
    path: src/background.ts
    content: >-
      <<<<<<< SEARCH

      import type { NotificationContext } from './types';


      // Context for notifications is stored in chrome.storage.local to survive

      // service worker termination. A `notification:` prefix is used for the
      key.


      function formatDuration(ms: number | null | undefined): string {
        if (!ms || ms < 1000) {
          return '';
        }

        // Round to nearest second
        const totalSeconds = Math.round(ms / 1000);

        if (totalSeconds < 60) {
          return `${totalSeconds}s`;
        }

        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;

        if (seconds === 0) {
          return `${minutes}m`;
        }

        return `${minutes}m ${seconds}s`;
      }


      /**
       * Creates and displays a desktop notification.
       * @param context - The context containing the tab and window IDs.
       */
      function createNotification(context: NotificationContext) {
        const durationText = formatDuration(context.durationMs);
        const durationPart = durationText ? `in ${durationText}` : '';

        let title: string;
        if (context.runName) {
          title = ['Finished', durationPart, `- ${context.runName}`]
            .filter(Boolean)
            .join(' ');
        } else {
          title = ['AI Studio Process Finished', durationPart]
            .filter(Boolean)
            .join(' ');
        }

        const message = `Your process has finished running.`;
        // The notificationId is guaranteed to be unique for the session.
        chrome.notifications.create(
          {
            type: 'basic',
            iconUrl: 'icon128.png',
            title: title,
            message: message,
            priority: 2,
            // `requireInteraction: false` is the default. It means the notification
            // will auto-dismiss after a short time. On some OSes (like Windows),
            // notifications with buttons may persist in an action center regardless.
            requireInteraction: false,
            buttons: [{ title: 'Dismiss' }, { title: 'Remind in 5 min' }],
          },
          (notificationId) => {
            if (notificationId) {
              const storageKey = `notification:${notificationId}`;
              chrome.storage.local.set({ [storageKey]: context });
              console.log(
                `Notification created: ${notificationId}. Context stored.`
              );
            }
          }
        );
      }


      // Listen for messages from the content script

      chrome.runtime.onMessage.addListener((message, sender) => {
        if (message.type === 'processFinished') {
          console.log('Background script received processFinished message.');

          if (sender.tab?.id && sender.tab?.windowId) {
            const context: NotificationContext = {
              tabId: sender.tab.id,
              windowId: sender.tab.windowId,
              durationMs: message.durationMs,
              runName: message.runName,
            };
            createNotification(context);
          } else {
            console.error(
              'Could not create notification: sender tab details are missing.'
            );
          }
        }
      });


      // Listener for when a user clicks the body of a notification

      chrome.notifications.onClicked.addListener(async (notificationId) => {
        const storageKey = `notification:${notificationId}`;
        const data = await chrome.storage.local.get(storageKey);
        const context = data[storageKey] as NotificationContext | undefined;

        if (!context) {
          console.warn(`No context found for clicked notification: ${notificationId}`);
          return;
        }

        // When the notification is clicked, focus the relevant tab
        chrome.windows.update(context.windowId, { focused: true });
        chrome.tabs.update(context.tabId, { active: true });

        // Clear the notification, which will also trigger onClosed for cleanup
        chrome.notifications.clear(notificationId);
      });

      =======

      import type {
        GlobalState,
        TabState,
        RunHistoryEntry,
        NotificationContext,
        Message,
      } from './types';


      // --- State Management ---


      const STATE_KEY = 'ai-studio-tracker-state';

      let state: GlobalState = {};

      let timerInterval: number | undefined;

      let ports: { [tabId: number]: chrome.runtime.Port } = {};


      async function getState(): Promise<GlobalState> {
        const result = await chrome.storage.local.get(STATE_KEY);
        return result[STATE_KEY] || {};
      }


      async function setState(newState: GlobalState): Promise<void> {
        state = newState;
        await chrome.storage.local.set({ [STATE_KEY]: newState });
        broadcastState();
      }


      function broadcastState() {
        for (const tabIdStr in ports) {
          const port = ports[tabIdStr];
          try {
            port.postMessage({ type: 'stateUpdate', state: state });
          } catch (e) {
            console.warn(`Could not send state to tab ${tabIdStr}, port is likely closed.`);
          }
        }
      }


      function getInitialTabState(tabId: number, windowId: number): TabState {
        return {
          tabId,
          windowId,
          status: 'monitoring',
          runName: null,
          startTime: null,
          elapsedTime: 0,
          pausedTime: 0,
          pauseStartTime: null,
          history: [],
          error: null,
          isVisible: true,
        };
      }


      // --- Timer for Elapsed Time ---


      function updateTimers() {
        let needsUpdate = false;
        const now = Date.now();

        for (const tabIdStr in state) {
          const tabId = parseInt(tabIdStr, 10);
          const tab = state[tabId];
          if (tab.status === 'running' && tab.startTime) {
            tab.elapsedTime = now - tab.startTime - tab.pausedTime;
            needsUpdate = true;
          }
        }

        if (needsUpdate) {
          state = { ...state };
          broadcastState();
        }

        const anyRunning = Object.values(state).some(
          (t) => t.status === 'running'
        );
        if (!anyRunning && timerInterval) {
          clearInterval(timerInterval);
          timerInterval = undefined;
        }
      }


      function ensureTimerIsRunning() {
        if (!timerInterval) {
          timerInterval = window.setInterval(updateTimers, 1000);
        }
      }


      // --- Port-based Communication ---


      chrome.runtime.onConnect.addListener((port) => {
        if (port.name !== 'content-script' || !port.sender?.tab?.id) {
          return;
        }
        const tabId = port.sender.tab.id;
        const windowId = port.sender.tab.windowId ?? -1;
        ports[tabId] = port;

        port.onMessage.addListener(async (message: Message) => {
          switch (message.type) {
            case 'startRun':
              await handleStartRun(tabId, message.runName);
              break;
            case 'stopRun':
              await handleStopRun(tabId, message.isError, message.error);
              break;
            case 'pauseResume':
              await handlePauseResume(tabId);
              break;
            case 'closeIndicator':
              await handleCloseIndicator(tabId);
              break;
            case 'navigateToTab':
              handleNavigateToTab(message.tabId, message.windowId);
              break;
            case 'error':
              const currentState = await getState();
              const tab = currentState[tabId];
              if (tab) {
                tab.status = 'error';
                tab.error = message.error;
                await setState(currentState);
              }
              break;
          }
        });

        port.onDisconnect.addListener(() => {
          delete ports[tabId];
          console.log(`Port disconnected for tab ${tabId}`);
        });

        // Handle initial connection
        (async () => {
          let currentState = await getState();
          if (!currentState[tabId]) {
            currentState[tabId] = getInitialTabState(tabId, windowId);
          } else {
            currentState[tabId].isVisible = true; // Make visible on reconnect
            currentState[tabId].windowId = windowId;
          }
          await setState(currentState);
          currentState = await getState(); // Re-read state after setState
          port.postMessage({
            type: 'init',
            tabId: tabId,
            state: currentState,
          });
        })();
      });



      async function handleStartRun(tabId: number, runName: string | null) {
        const currentState = await getState();
        const tab = currentState[tabId];
        if (!tab) return;

        tab.status = 'running';
        tab.startTime = Date.now();
        tab.runName = runName;
        tab.elapsedTime = 0;
        tab.pausedTime = 0;
        tab.pauseStartTime = null;
        tab.error = null;

        await setState(currentState);
        ensureTimerIsRunning();
      }


      async function handleStopRun(
        tabId: number,
        isError = false,
        error?: string
      ) {
        const currentState = await getState();
        const tab = currentState[tabId];
        if (!tab || tab.status === 'monitoring' || tab.status === 'stopped') return;

        const endTime = Date.now();
        const finalElapsedTime = tab.startTime
          ? endTime - tab.startTime - tab.pausedTime
          : 0;

        const finalStatus = isError ? 'error' : 'stopped';

        const historyEntry: RunHistoryEntry = {
          id: `${tabId}-${endTime}`,
          runName: tab.runName,
          durationMs: finalElapsedTime,
          status: finalStatus,
          endTime: endTime,
        };
        tab.history.unshift(historyEntry);
        if (tab.history.length > 20) {
          tab.history.pop();
        }

        tab.status = 'stopped';
        tab.startTime = null;
        tab.runName = null;
        tab.elapsedTime = finalElapsedTime;
        tab.error = error || null;

        await setState(currentState);

        if (finalElapsedTime >= 3000) {
          console.log(
            `AI Studio process finished. Sending notification for run: "${historyEntry.runName}".`
          );
          createNotification({
            tabId: tab.tabId,
            windowId: tab.windowId,
            durationMs: finalElapsedTime,
            runName: historyEntry.runName,
          });
        }
      }


      async function handlePauseResume(tabId: number) {
        const currentState = await getState();
        const tab = currentState[tabId];
        if (!tab) return;

        if (tab.status === 'running') {
          tab.pauseStartTime = Date.now();
          tab.status = 'paused';
          // Update elapsed time one last time before pausing interval
          if (tab.startTime) {
              tab.elapsedTime = Date.now() - tab.startTime - tab.pausedTime;
          }

        } else if (tab.status === 'paused') {
          if (tab.pauseStartTime) {
            tab.pausedTime += Date.now() - tab.pauseStartTime;
          }
          tab.pauseStartTime = null;
          tab.status = 'running';
          ensureTimerIsRunning();
        }
        await setState(currentState);
      }


      async function handleCloseIndicator(tabId: number) {
        const currentState = await getState();
        const tab = currentState[tabId];
        if (tab) {
          tab.isVisible = false;
          await setState(currentState);
        }
      }


      function handleNavigateToTab(tabId: number, windowId: number) {
        chrome.windows.update(windowId, { focused: true });
        chrome.tabs.update(tabId, { active: true });
      }


      // --- Tab Lifecycle Management ---


      chrome.tabs.onRemoved.addListener(async (tabId) => {
        const currentState = await getState();
        if (currentState[tabId]) {
          delete currentState[tabId];
          await setState(currentState);
        }
      });



      // --- Notification Logic ---


      function formatDuration(ms: number | null | undefined): string {
        if (!ms || ms < 1000) {
          return '';
        }
        const totalSeconds = Math.round(ms / 1000);
        if (totalSeconds < 60) {
          return `${totalSeconds}s`;
        }
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;
        if (seconds === 0) {
          return `${minutes}m`;
        }
        return `${minutes}m ${seconds}s`;
      }


      function createNotification(context: NotificationContext) {
        const durationText = formatDuration(context.durationMs);
        const durationPart = durationText ? `in ${durationText}` : '';

        let title: string;
        if (context.runName) {
          title = ['Finished', durationPart, `- ${context.runName}`]
            .filter(Boolean)
            .join(' ');
        } else {
          title = ['AI Studio Process Finished', durationPart]
            .filter(Boolean)
            .join(' ');
        }

        const message = `Your process has finished running.`;
        chrome.notifications.create(
          {
            type: 'basic',
            iconUrl: 'icon128.png',
            title: title,
            message: message,
            priority: 2,
            requireInteraction: false,
            buttons: [{ title: 'Dismiss' }, { title: 'Remind in 5 min' }],
          },
          (notificationId) => {
            if (notificationId) {
              const storageKey = `notification:${notificationId}`;
              chrome.storage.local.set({ [storageKey]: context });
              console.log(
                `Notification created: ${notificationId}. Context stored.`
              );
            }
          }
        );
      }


      chrome.notifications.onClicked.addListener(async (notificationId) => {
        const storageKey = `notification:${notificationId}`;
        const data = await chrome.storage.local.get(storageKey);
        const context = data[storageKey] as NotificationContext | undefined;

        if (!context) {
          console.warn(`No context found for clicked notification: ${notificationId}`);
          return;
        }

        handleNavigateToTab(context.tabId, context.windowId);
        chrome.notifications.clear(notificationId);
      });

      >>>>>>> REPLACE

      <<<<<<< SEARCH

      // Listener for when a user clicks a button on the notification

      chrome.notifications.onButtonClicked.addListener(
        async (notificationId, buttonIndex) => {
          const storageKey = `notification:${notificationId}`;
          const data = await chrome.storage.local.get(storageKey);
          const context = data[storageKey] as NotificationContext | undefined;

          if (!context) {
            console.warn(`No context found for notification: ${notificationId}`);
            return;
          }

          switch (buttonIndex) {
            case 0: // Dismiss
              chrome.notifications.clear(notificationId);
              break;
            case 1: // Remind in 5 min
              {
                const alarmName = `remind-${notificationId}`;
                // Store context for when the alarm fires
                await chrome.storage.local.set({ [alarmName]: context });
                chrome.alarms.create(alarmName, { delayInMinutes: 5 });
                // Clearing the notification will also trigger onClosed, which cleans
                // up the original `notification:<id>` storage.
                chrome.notifications.clear(notificationId);
              }
              break;
          }
        }
      );

      =======

      chrome.notifications.onButtonClicked.addListener(
        async (notificationId, buttonIndex) => {
          const storageKey = `notification:${notificationId}`;
          const data = await chrome.storage.local.get(storageKey);
          const context = data[storageKey] as NotificationContext | undefined;

          if (!context) {
            console.warn(`No context found for notification: ${notificationId}`);
            return;
          }

          switch (buttonIndex) {
            case 0: // Dismiss
              chrome.notifications.clear(notificationId);
              break;
            case 1: // Remind in 5 min
              {
                const alarmName = `remind-${notificationId}`;
                await chrome.storage.local.set({ [alarmName]: context });
                chrome.alarms.create(alarmName, { delayInMinutes: 5 });
                chrome.notifications.clear(notificationId);
              }
              break;
          }
        }
      );

      >>>>>>> REPLACE

      <<<<<<< SEARCH

      // Listener for alarms (for the "Remind" feature)

      chrome.alarms.onAlarm.addListener(async (alarm) => {
        if (alarm.name.startsWith('remind-')) {
          const data = await chrome.storage.local.get(alarm.name);
          const context = data[alarm.name] as NotificationContext | undefined;

          if (context) {
            console.log(`Re-creating notification from alarm: ${alarm.name}`);
            createNotification(context);
            // Clean up the storage
            await chrome.storage.local.remove(alarm.name);
          }
        }
      });

      =======

      chrome.alarms.onAlarm.addListener(async (alarm) => {
        if (alarm.name.startsWith('remind-')) {
          const data = await chrome.storage.local.get(alarm.name);
          const context = data[alarm.name] as NotificationContext | undefined;

          if (context) {
            console.log(`Re-creating notification from alarm: ${alarm.name}`);
            createNotification(context);
            await chrome.storage.local.remove(alarm.name);
          }
        }
      });


      // --- Service Worker Startup ---

      (async () => {
        state = await getState();
        console.log('AI Studio Notifier: Background state loaded.');

        const tabs = await chrome.tabs.query({});
        const existingTabIds = new Set(tabs.map((t) => t.id).filter(Boolean));
        const stateTabIds = Object.keys(state).map(Number);
        let stateChanged = false;

        for (const tabId of stateTabIds) {
          if (!existingTabIds.has(tabId)) {
            delete state[tabId];
            stateChanged = true;
          }
        }

        if (stateChanged) {
          await setState(state);
        }

        if (Object.values(state).some((t) => t.status === 'running')) {
          ensureTimerIsRunning();
        }
      })();

      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: src/content/App.tsx
    content: |-
      import { useState, useEffect, useCallback, useRef } from 'react';
      import Indicator from './Indicator';
      import type { GlobalState } from '../types';

      /**
       * Captures the current tab's title to use as the run name.
       * This makes notifications more informative.
       * @returns The tab's title, or null if it's empty.
       */
      function captureRunContext(): string | null {
        try {
          const title = document.title?.trim();
          if (title) {
            // Clean up the title, e.g., remove " - Google AI Studio"
            return title.replace(/ - Google AI Studio$/, '').trim();
          }
        } catch (e) {
          console.error(
            'AI Studio Notifier: Error capturing run context from tab title.',
            e
          );
        }
        return null;
      }

      function App() {
        const [tabId, setTabId] = useState<number | null>(null);
        const [globalState, setGlobalState] = useState<GlobalState>({});
        const lastKnownStopButtonState = useRef<boolean>(false);
        const portRef = useRef<chrome.runtime.Port | null>(null);

        useEffect(() => {
          portRef.current = chrome.runtime.connect({ name: 'content-script' });

          portRef.current.onMessage.addListener((message: any) => {
            if (message.type === 'init') {
              setTabId(message.tabId);
              setGlobalState(message.state);
            } else if (message.type === 'stateUpdate') {
              setGlobalState(message.state);
            }
          });

          const port = portRef.current;
          return () => {
            port.disconnect();
            portRef.current = null;
          };
        }, []);

        const postMessage = useCallback((message: any) => {
          try {
            if (portRef.current) {
              portRef.current.postMessage(message);
            }
          } catch (e) {
            console.warn('Could not post message, port may be disconnected.', e);
          }
        }, []);

        const checkState = useCallback(() => {
          if (!tabId) return;
          const currentTabState = globalState[tabId];
          if (!currentTabState || currentTabState.status === 'paused') {
            return;
          }

          try {
            const stopButtonExists = !!document.querySelector<SVGRectElement>(
              'rect[class*="stoppable-stop"]'
            );
            if (stopButtonExists !== lastKnownStopButtonState.current) {
              lastKnownStopButtonState.current = stopButtonExists;
              if (stopButtonExists) {
                postMessage({ type: 'startRun', runName: captureRunContext() });
              } else {
                postMessage({ type: 'stopRun' });
              }
            }
          } catch (e) {
            console.error('AI Studio Notifier: Error during state check.', e);
            postMessage({ type: 'error', error: 'An error occurred during check.' });
          }
        }, [globalState, tabId, postMessage]);

        useEffect(() => {
          if (!tabId) return;
          const currentTabState = globalState[tabId];
          if (currentTabState?.status === 'paused') {
            return;
          }

          const timeoutId = setTimeout(checkState, 1000);
          const observer = new MutationObserver(checkState);
          observer.observe(document.body, { childList: true, subtree: true });

          return () => {
            clearTimeout(timeoutId);
            observer.disconnect();
          };
        }, [checkState, tabId, globalState]);

        const handlePauseResume = useCallback(
          () => postMessage({ type: 'pauseResume' }),
          [postMessage]
        );
        const handleClose = useCallback(
          () => postMessage({ type: 'closeIndicator' }),
          [postMessage]
        );
        const handleNavigate = useCallback(
          (navTabId: number, windowId: number) => {
            postMessage({ type: 'navigateToTab', tabId: navTabId, windowId });
          },
          [postMessage]
        );

        if (!tabId || !globalState[tabId]?.isVisible) {
          return null;
        }

        const currentTabState = globalState[tabId];
        if (!currentTabState) return null; // Should not happen if tabId is set

        return (
          <Indicator
            currentTabState={currentTabState}
            allTabsState={globalState}
            onPauseResume={handlePauseResume}
            onClose={handleClose}
            onNavigate={handleNavigate}
          />
        );
      }

      export default App;
    patchStrategy: replace
  - type: write
    path: src/content/Indicator.tsx
    content: |-
      import { useRef, useEffect, useState } from 'react';
      import { useDrag } from './useDrag';
      import { statusConfig } from './constants';
      import type { IndicatorProps, RunHistoryEntry, TabState } from '../types';

      function formatElapsedTime(ms: number): string {
        if (ms <= 0) return '00:00';
        const totalSeconds = Math.floor(ms / 1000);
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;
        const paddedMinutes = String(minutes).padStart(2, '0');
        const paddedSeconds = String(seconds).padStart(2, '0');
        return `${paddedMinutes}:${paddedSeconds}`;
      }

      function HistoryEntry({
        entry,
        onClick,
      }: {
        entry: RunHistoryEntry;
        onClick: () => void;
      }) {
        return (
          <div
            className="flex items-center justify-between text-xs px-2 py-1 hover:bg-white/10 rounded cursor-pointer"
            onClick={onClick}
          >
            <div className="flex items-center gap-2">
              <span
                className={
                  entry.status === 'stopped' ? 'text-green-400' : 'text-red-400'
                }
              >
                {entry.status === 'stopped' ? '✔' : '✖'}
              </span>
              <span className="truncate max-w-[180px] text-gray-300">
                {entry.runName || 'Untitled Run'}
              </span>
            </div>
            <span className="font-mono text-gray-400">
              {formatElapsedTime(entry.durationMs)}
            </span>
          </div>
        );
      }

      function TabHistory({
        tabState,
        onNavigate,
      }: {
        tabState: TabState;
        onNavigate: (tabId: number, windowId: number) => void;
      }) {
        if (tabState.history.length === 0) return null;

        return (
          <div className="mt-2">
            <div
              className="text-xs font-bold text-gray-200 px-2 py-1 cursor-pointer hover:underline truncate"
              onClick={() => onNavigate(tabState.tabId, tabState.windowId)}
              title={tabState.history[0].runName || `Tab ${tabState.tabId}`}
            >
              Tab: {tabState.history[0].runName || `Tab ${tabState.tabId}`}
            </div>
            <div className="flex flex-col gap-0.5">
              {tabState.history.map((entry) => (
                <HistoryEntry
                  key={entry.id}
                  entry={entry}
                  onClick={() => onNavigate(tabState.tabId, tabState.windowId)}
                />
              ))}
            </div>
          </div>
        );
      }

      function Indicator({
        currentTabState,
        allTabsState,
        onPauseResume,
        onClose,
        onNavigate,
      }: IndicatorProps) {
        const indicatorRef = useRef<HTMLDivElement>(null);
        const { position, handleMouseDown } = useDrag(indicatorRef);
        const [isExpanded, setIsExpanded] = useState(false);
        const audioRef = useRef<HTMLAudioElement | null>(null);

        useEffect(() => {
          // Preload audio element when component mounts
          const soundUrl = chrome.runtime.getURL('notification.mp3');
          audioRef.current = new Audio(soundUrl);
        }, []);

        useEffect(() => {
          if (currentTabState?.status === 'stopped') {
            audioRef.current
              ?.play()
              .catch((err) => console.error('Audio play failed: ', err));
          }
        }, [currentTabState?.status]);

        if (!currentTabState) {
          return null;
        }

        const config = statusConfig[currentTabState.status];
        const isPausable =
          currentTabState.status === 'running' ||
          currentTabState.status === 'paused' ||
          currentTabState.status === 'monitoring';

        const historyTabs = Object.values(allTabsState)
          .filter((tab) => tab.history.length > 0)
          .sort((a, b) => {
            const aLast = a.history[0]?.endTime ?? 0;
            const bLast = b.history[0]?.endTime ?? 0;
            return bLast - aLast;
          });

        const totalRuns = historyTabs.reduce(
          (sum, tab) => sum + tab.history.length,
          0
        );
        const totalDuration = historyTabs.reduce(
          (sum, tab) =>
            sum + tab.history.reduce((tabSum, run) => tabSum + run.durationMs, 0),
          0
        );
        const avgDuration = totalRuns > 0 ? totalDuration / totalRuns : 0;

        return (
          <div
            ref={indicatorRef}
            className="fixed top-0 left-0 z-[99999] rounded-lg shadow-lg text-white font-sans select-none w-64"
            style={{
              transform: `translate3d(${position.x}px, ${position.y}px, 0)`,
              backgroundColor: 'rgba(20, 20, 20, 0.8)',
              backdropFilter: 'blur(4px)',
            }}
          >
            <div
              className="flex items-center gap-3 p-2 cursor-grab"
              onMouseDown={handleMouseDown}
            >
              <div className="flex items-center gap-2 flex-grow min-w-0">
                <span
                  className={`w-3 h-3 rounded-full flex-shrink-0 ${config.bgColor} ${
                    config.animate ? 'animate-pulse' : ''
                  }`}
                ></span>
                <span className="text-sm font-medium truncate">
                  {currentTabState.runName
                    ? currentTabState.runName
                    : config.text}
                </span>
                {(currentTabState.status === 'running' ||
                  currentTabState.status === 'paused' ||
                  currentTabState.status === 'stopped') && (
                  <span className="text-sm font-mono text-gray-300">
                    {formatElapsedTime(currentTabState.elapsedTime)}
                  </span>
                )}
              </div>
              <div className="flex items-center flex-shrink-0">
                {isPausable && (
                  <button
                    onClick={onPauseResume}
                    className="text-gray-400 hover:text-white cursor-pointer p-1 rounded-full"
                    title={currentTabState.status === 'paused' ? 'Resume' : 'Pause'}
                  >
                    {currentTabState.status === 'running' ||
                    currentTabState.status === 'monitoring' ? (
                      <svg
                        xmlns="http://www.w3.org/2000/svg"
                        width="12"
                        height="12"
                        viewBox="0 0 24 24"
                        fill="currentColor"
                        className="block"
                      >
                        <path d="M14 19h4V5h-4v14zm-8 0h4V5H6v14z" />
                      </svg>
                    ) : (
                      <svg
                        xmlns="http://www.w3.org/2000/svg"
                        width="12"
                        height="12"
                        viewBox="0 0 24 24"
                        fill="currentColor"
                        className="block"
                      >
                        <path d="M8 5v14l11-7z" />
                      </svg>
                    )}
                  </button>
                )}
                {historyTabs.length > 0 && (
                  <button
                    onClick={() => setIsExpanded(!isExpanded)}
                    className="text-gray-400 hover:text-white cursor-pointer p-1 rounded-full"
                    title={isExpanded ? 'Collapse History' : 'Expand History'}
                  >
                    <svg
                      xmlns="http://www.w3.org/2000/svg"
                      width="12"
                      height="12"
                      viewBox="0 0 24 24"
                      fill="currentColor"
                      className="block transition-transform"
                      style={{ transform: isExpanded ? 'rotate(180deg)' : 'none' }}
                    >
                      <path d="M7.41 8.59 12 13.17l4.59-4.58L18 10l-6 6-6-6z" />
                    </svg>
                  </button>
                )}
                <button
                  onClick={onClose}
                  className="text-gray-400 hover:text-white cursor-pointer p-1 rounded-full"
                  title="Hide Indicator"
                >
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    width="12"
                    height="12"
                    viewBox="0 0 24 24"
                    fill="currentColor"
                    className="block"
                  >
                    <path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z" />
                  </svg>
                </button>
              </div>
            </div>
            {currentTabState.status === 'error' && currentTabState.error && (
              <p className="text-xs text-red-400 px-2 pb-2 -mt-1">
                {currentTabState.error}
              </p>
            )}

            {/* Expanded History View */}
            {isExpanded && (
              <div className="p-2 border-t border-white/10">
                {historyTabs.length > 0 ? (
                  <>
                    <div className="flex justify-between items-baseline px-2 pb-2">
                      <h3 className="text-sm font-bold">Run History</h3>
                      <p className="text-xs text-gray-400">
                        Avg: {formatElapsedTime(avgDuration)}
                      </p>
                    </div>
                    <div className="max-h-60 overflow-y-auto pr-1">
                      {historyTabs.map((tabState) => (
                        <TabHistory
                          key={tabState.tabId}
                          tabState={tabState}
                          onNavigate={onNavigate}
                        />
                      ))}
                    </div>
                  </>
                ) : (
                  <p className="text-xs text-gray-400 text-center py-2">
                    No completed runs in this session.
                  </p>
                )}
              </div>
            )}
          </div>
        );
      }

      export default Indicator;
    patchStrategy: replace
snapshot:
  src/types.ts: |-
    export interface NotificationContext {
      tabId: number;
      windowId: number;
      durationMs?: number | null;
      runName?: string | null;
    }
  src/content/types.ts: >-
    export type Status = 'monitoring' | 'running' | 'stopped' | 'error' |
    'paused';


    export interface IndicatorProps {
      status: Status;
      error: string | null;
      elapsedTime: number;
      onPauseResume: () => void;
      runName: string | null;
    }
  src/background.ts: |-
    import type { NotificationContext } from './types';

    // Context for notifications is stored in chrome.storage.local to survive
    // service worker termination. A `notification:` prefix is used for the key.

    function formatDuration(ms: number | null | undefined): string {
      if (!ms || ms < 1000) {
        return '';
      }

      // Round to nearest second
      const totalSeconds = Math.round(ms / 1000);

      if (totalSeconds < 60) {
        return `${totalSeconds}s`;
      }

      const minutes = Math.floor(totalSeconds / 60);
      const seconds = totalSeconds % 60;

      if (seconds === 0) {
        return `${minutes}m`;
      }

      return `${minutes}m ${seconds}s`;
    }

    /**
     * Creates and displays a desktop notification.
     * @param context - The context containing the tab and window IDs.
     */
    function createNotification(context: NotificationContext) {
      const durationText = formatDuration(context.durationMs);
      const durationPart = durationText ? `in ${durationText}` : '';

      let title: string;
      if (context.runName) {
        title = ['Finished', durationPart, `- ${context.runName}`]
          .filter(Boolean)
          .join(' ');
      } else {
        title = ['AI Studio Process Finished', durationPart]
          .filter(Boolean)
          .join(' ');
      }

      const message = `Your process has finished running.`;
      // The notificationId is guaranteed to be unique for the session.
      chrome.notifications.create(
        {
          type: 'basic',
          iconUrl: 'icon128.png',
          title: title,
          message: message,
          priority: 2,
          // `requireInteraction: false` is the default. It means the notification
          // will auto-dismiss after a short time. On some OSes (like Windows),
          // notifications with buttons may persist in an action center regardless.
          requireInteraction: false,
          buttons: [{ title: 'Dismiss' }, { title: 'Remind in 5 min' }],
        },
        (notificationId) => {
          if (notificationId) {
            const storageKey = `notification:${notificationId}`;
            chrome.storage.local.set({ [storageKey]: context });
            console.log(
              `Notification created: ${notificationId}. Context stored.`
            );
          }
        }
      );
    }

    // Listen for messages from the content script
    chrome.runtime.onMessage.addListener((message, sender) => {
      if (message.type === 'processFinished') {
        console.log('Background script received processFinished message.');

        if (sender.tab?.id && sender.tab?.windowId) {
          const context: NotificationContext = {
            tabId: sender.tab.id,
            windowId: sender.tab.windowId,
            durationMs: message.durationMs,
            runName: message.runName,
          };
          createNotification(context);
        } else {
          console.error(
            'Could not create notification: sender tab details are missing.'
          );
        }
      }
    });

    // Listener for when a user clicks the body of a notification
    chrome.notifications.onClicked.addListener(async (notificationId) => {
      const storageKey = `notification:${notificationId}`;
      const data = await chrome.storage.local.get(storageKey);
      const context = data[storageKey] as NotificationContext | undefined;

      if (!context) {
        console.warn(`No context found for clicked notification: ${notificationId}`);
        return;
      }

      // When the notification is clicked, focus the relevant tab
      chrome.windows.update(context.windowId, { focused: true });
      chrome.tabs.update(context.tabId, { active: true });

      // Clear the notification, which will also trigger onClosed for cleanup
      chrome.notifications.clear(notificationId);
    });

    // Listener for when a user clicks a button on the notification
    chrome.notifications.onButtonClicked.addListener(
      async (notificationId, buttonIndex) => {
        const storageKey = `notification:${notificationId}`;
        const data = await chrome.storage.local.get(storageKey);
        const context = data[storageKey] as NotificationContext | undefined;

        if (!context) {
          console.warn(`No context found for notification: ${notificationId}`);
          return;
        }

        switch (buttonIndex) {
          case 0: // Dismiss
            chrome.notifications.clear(notificationId);
            break;
          case 1: // Remind in 5 min
            {
              const alarmName = `remind-${notificationId}`;
              // Store context for when the alarm fires
              await chrome.storage.local.set({ [alarmName]: context });
              chrome.alarms.create(alarmName, { delayInMinutes: 5 });
              // Clearing the notification will also trigger onClosed, which cleans
              // up the original `notification:<id>` storage.
              chrome.notifications.clear(notificationId);
            }
            break;
        }
      }
    );

    // Listener for when a notification is closed (programmatically or by user)
    // This is crucial for cleaning up storage to prevent exceeding quotas.
    chrome.notifications.onClosed.addListener((notificationId) => {
      const storageKey = `notification:${notificationId}`;
      // We don't need to await this, it can run in the background.
      chrome.storage.local.remove(storageKey);
      console.log(
        `Cleaned up storage for closed notification: ${notificationId}`
      );
    });

    // Listener for alarms (for the "Remind" feature)
    chrome.alarms.onAlarm.addListener(async (alarm) => {
      if (alarm.name.startsWith('remind-')) {
        const data = await chrome.storage.local.get(alarm.name);
        const context = data[alarm.name] as NotificationContext | undefined;

        if (context) {
          console.log(`Re-creating notification from alarm: ${alarm.name}`);
          createNotification(context);
          // Clean up the storage
          await chrome.storage.local.remove(alarm.name);
        }
      }
    });
  src/content/App.tsx: |-
    import { useState, useEffect, useCallback, useRef } from 'react';
    import Indicator from './Indicator';
    import type { Status } from './types';

    /**
     * Captures the current tab's title to use as the run name.
     * This makes notifications more informative.
     * @returns The tab's title, or null if it's empty.
     */
    function captureRunContext(): string | null {
      try {
        const title = document.title?.trim();
        if (title) {
          // Clean up the title, e.g., remove " - Google AI Studio"
          return title.replace(/ - Google AI Studio$/, '').trim();
        }
      } catch (e) {
        console.error(
          'AI Studio Notifier: Error capturing run context from tab title.',
          e
        );
      }
      return null;
    }

    function App() {
      const [status, setStatus] = useState<Status>('monitoring');
      const [error, setError] = useState<string | null>(null);
      const [runName, setRunName] = useState<string | null>(null);
      const startTimeRef = useRef<number | null>(null);
      const [elapsedTime, setElapsedTime] = useState(0);
      const pausedTimeRef = useRef(0);
      const pauseStartRef = useRef<number | null>(null);
      const prePauseStatusRef = useRef<Status>('monitoring');

      useEffect(() => {
        let intervalId: number | undefined;

        if (status === 'running') {
          intervalId = window.setInterval(() => {
            if (startTimeRef.current) {
              const now = Date.now();
              const totalElapsed =
                now - startTimeRef.current - pausedTimeRef.current;
              setElapsedTime(totalElapsed);
            }
          }, 1000);
        }

        return () => {
          if (intervalId) {
            clearInterval(intervalId);
          }
        };
      }, [status]);

      const handlePauseResume = useCallback(() => {
        setStatus((currentStatus) => {
          if (currentStatus === 'running' || currentStatus === 'monitoring') {
            // Pausing
            prePauseStatusRef.current = currentStatus; // Store where we came from

            if (currentStatus === 'running') {
              pauseStartRef.current = Date.now();
              // Update elapsed time one last time before pausing interval
              if (startTimeRef.current) {
                setElapsedTime(
                  Date.now() - startTimeRef.current - pausedTimeRef.current
                );
              }
            }
            return 'paused';
          }

          if (currentStatus === 'paused') {
            // Resuming
            const resumeTo = prePauseStatusRef.current;
            if (resumeTo === 'running') {
              if (pauseStartRef.current) {
                pausedTimeRef.current += Date.now() - pauseStartRef.current;
                pauseStartRef.current = null;
              }
            }
            // Resume to the state we were in before pausing
            return resumeTo;
          }

          return currentStatus;
        });
      }, []);

      const checkState = useCallback(() => {
        try {
          const stopButtonExists = !!document.querySelector<SVGRectElement>(
            'rect[class*="stoppable-stop"]'
          );

          // Don't do anything if paused. The pause/resume button is the only source of truth.
          if (status === 'paused') {
            return;
          }

          const wasRunning = status === 'running';

          // --- Transition: running -> stopped ---
          if (wasRunning && !stopButtonExists) {
            const endTime = Date.now();
            const finalElapsedTime = startTimeRef.current
              ? endTime - startTimeRef.current - pausedTimeRef.current
              : 0;
            setElapsedTime(finalElapsedTime < 0 ? 0 : finalElapsedTime);

            if (finalElapsedTime >= 3000) {
              console.log(
                `AI Studio process finished. Sending desktop notification for run: "${runName}".`
              );
              chrome.runtime.sendMessage({
                type: 'processFinished',
                durationMs: finalElapsedTime,
                runName: runName,
              });
            } else {
              console.log(
                'AI Studio process finished in under 3 seconds. Skipping desktop notification.'
              );
            }

            startTimeRef.current = null;
            pausedTimeRef.current = 0;
            pauseStartRef.current = null;
            setStatus('stopped');
            return; // End execution for this check
          }

          const newStatus = stopButtonExists ? 'running' : 'monitoring';

          // No state change, do nothing.
          if (newStatus === status) {
            return;
          }

          // --- Transition: stopped -> monitoring ---
          // This happens when the user clears the output. We want to stay in the 'stopped'
          // state visually until a new run is explicitly started.
          if (status === 'stopped' && newStatus === 'monitoring') {
            // We reset the run name here so the indicator clears.
            if (runName) setRunName(null);
            return;
          }

          // --- Transition: (monitoring | stopped) -> running ---
          if (newStatus === 'running') {
            // This covers transitions from 'monitoring' or 'stopped' to 'running'
            console.log('AI Studio Notifier: State changed to Running');
            startTimeRef.current = Date.now();
            pausedTimeRef.current = 0;
            pauseStartRef.current = null;
            setElapsedTime(0);
            setRunName(captureRunContext());
            setStatus('running');
            setError(null);
            return;
          }

          // --- Any other transition (e.g., running -> monitoring, which shouldn't happen) ---
          console.log(`AI Studio Notifier: State changed to ${newStatus}`);
          setStatus(newStatus);
          setError(null);
        } catch (e) {
          console.error('AI Studio Notifier: Error during state check.', e);
          setError('An error occurred during check.');
          setStatus('error');
        }
      }, [status, runName]);

      useEffect(() => {
        // When paused, the observer should not be active to save resources.
        if (status === 'paused') {
          // The cleanup function of the previous effect run has already disconnected
          // the observer. We don't set up a new one while paused.
          return;
        }

        // Initial Check after a short delay
        const timeoutId = setTimeout(checkState, 2000);

        // Observer Setup
        const observer = new MutationObserver(checkState);
        observer.observe(document.body, {
          childList: true,
          subtree: true,
        });
        console.log(
          'AI Studio Notifier: MutationObserver is now watching the page.'
        );

        return () => {
          clearTimeout(timeoutId);
          observer.disconnect();
          console.log('AI Studio Notifier: MutationObserver disconnected.');
        };
      }, [checkState, status]);

      return (
        <Indicator
          status={status}
          error={error}
          elapsedTime={elapsedTime}
          onPauseResume={handlePauseResume}
          runName={runName}
        />
      );
    }

    export default App;
  src/content/Indicator.tsx: |-
    import { useRef, useEffect, useState } from 'react';
    import { useDrag } from './useDrag';
    import { statusConfig } from './constants';
    import type { IndicatorProps } from './types';

    function formatElapsedTime(ms: number): string {
      if (ms <= 0) return '00:00';
      const totalSeconds = Math.floor(ms / 1000);
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = totalSeconds % 60;
      const paddedMinutes = String(minutes).padStart(2, '0');
      const paddedSeconds = String(seconds).padStart(2, '0');
      return `${paddedMinutes}:${paddedSeconds}`;
    }

    function Indicator({
      status,
      error,
      elapsedTime,
      onPauseResume,
      runName,
    }: IndicatorProps) {
      const indicatorRef = useRef<HTMLDivElement>(null);
      const { position, handleMouseDown } = useDrag(indicatorRef);
      const [isVisible, setIsVisible] = useState(true);
      const audioRef = useRef<HTMLAudioElement | null>(null);

      useEffect(() => {
        // Preload audio element when component mounts
        const soundUrl = chrome.runtime.getURL('notification.mp3');
        audioRef.current = new Audio(soundUrl);
      }, []);

      useEffect(() => {
        if (status === 'stopped') {
          audioRef.current
            ?.play()
            .catch((err) => console.error('Audio play failed: ', err));
        }
      }, [status]);

      if (!isVisible) {
        return null;
      }

      const config = statusConfig[status];
      const isPausable =
        status === 'running' || status === 'paused' || status === 'monitoring';

      return (
        <div
          ref={indicatorRef}
          className="fixed top-0 left-0 z-[99999] rounded-lg shadow-lg text-white font-sans select-none"
          style={{
            transform: `translate3d(${position.x}px, ${position.y}px, 0)`,
            backgroundColor: 'rgba(20, 20, 20, 0.8)',
            backdropFilter: 'blur(4px)',
          }}
        >
          <div
            className="flex items-center gap-3 p-2 cursor-grab"
            onMouseDown={handleMouseDown}
          >
            <div className="flex items-center gap-2">
              <span
                className={`w-3 h-3 rounded-full ${config.bgColor} ${
                  config.animate ? 'animate-pulse' : ''
                }`}
              ></span>
              <span className="text-sm font-medium">{config.text}</span>
              {runName && (
                <span className="text-sm font-light text-gray-300 truncate max-w-[150px] pl-1">
                  - {runName}
                </span>
              )}
              {(status === 'running' ||
                status === 'paused' ||
                status === 'stopped') && (
                <span className="text-sm font-mono text-gray-300">
                  {formatElapsedTime(elapsedTime)}
                </span>
              )}
            </div>
            <div className="flex items-center">
              {isPausable && (
                <button
                  onClick={onPauseResume}
                  className="text-gray-400 hover:text-white cursor-pointer p-1 rounded-full"
                  title={status === 'paused' ? 'Resume' : 'Pause'}
                >
                  {status === 'running' || status === 'monitoring' ? (
                    <svg
                      xmlns="http://www.w3.org/2000/svg"
                      width="12"
                      height="12"
                      viewBox="0 0 24 24"
                      fill="currentColor"
                      className="block"
                    >
                      <path d="M14 19h4V5h-4v14zm-8 0h4V5H6v14z" />
                    </svg>
                  ) : (
                    <svg
                      xmlns="http://www.w3.org/2000/svg"
                      width="12"
                      height="12"
                      viewBox="0 0 24 24"
                      fill="currentColor"
                      className="block"
                    >
                      <path d="M8 5v14l11-7z" />
                    </svg>
                  )}
                </button>
              )}
              <button
                onClick={() => setIsVisible(false)}
                className="text-gray-400 hover:text-white cursor-pointer p-1 rounded-full"
                title="Hide Indicator"
              >
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  width="12"
                  height="12"
                  viewBox="0 0 24 24"
                  fill="currentColor"
                  className="block"
                >
                  <path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z" />
                </svg>
              </button>
            </div>
          </div>
          {status === 'error' && error && (
            <p className="text-xs text-red-400 px-2 pb-2 -mt-1">{error}</p>
          )}
        </div>
      );
    }

    export default Indicator;
approved: true
