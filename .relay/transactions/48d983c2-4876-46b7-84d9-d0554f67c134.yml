uuid: 48d983c2-4876-46b7-84d9-d0554f67c134
projectId: google-ai-studio-notification
createdAt: '2025-08-06T09:59:57.309Z'
linesAdded: 83
linesRemoved: 22
gitCommitMsg: 'feat(ui): display connection status in indicator'
promptSummary: >-
  The user wants the floating indicator to show the connection status, so they
  know what to do if the extension context is invalidated or the connection to
  the background script is lost. This involves updating the UI to reflect
  connection state and disabling certain features when not connected.
reasoning:
  - >-
    Of course. It's a great idea to provide visual feedback to the user when the
    extension is not working correctly. I'll update the indicator to show the
    connection status. This will make it clear when there's an issue and what
    the user might need to do, like reloading the tab.
  - 'Here are the changes I''ll make:'
  - >-
    1.  **State Management**: I'll introduce a new `connectionStatus` state in
    the main `App` component to track the connection to the background script.
  - >-
    2.  **UI Feedback**: The `Indicator` component will now display the current
    connection status. If it's not connected, it will show a relevant message
    (e.g., "Connecting...", "Disconnected...", or "Error: Please reload tab").
  - >-
    3.  **Conditional UI**: When the indicator is not connected, I will hide
    non-essential UI elements like the pause/resume button, the timer, and the
    run history panel to reduce confusion.
  - Let's apply these changes.
  - '### 1. Update Type Definitions'
  - >-
    First, I'll update our type definitions to include the new connection
    status.
  - '### 2. Add Configuration for Connection Status'
  - >-
    Next, I'll add a configuration object for the different connection statuses,
    similar to how run statuses are handled.
  - '### 3. Update Application Logic'
  - >-
    I'll now update the core application logic in `App.tsx` to manage and pass
    down the connection status.
  - '### 4. Update the Indicator Component'
  - >-
    Finally, I'll update the `Indicator` component to render the UI based on the
    new `connectionStatus` prop.
  - >-
    These changes will ensure the indicator provides clear feedback on its
    connection state, improving the user experience and making the extension
    easier to troubleshoot.
  - '---'
operations:
  - type: write
    path: src/types.ts
    content: >-
      <<<<<<< SEARCH

      export type Status = 'monitoring' | 'running' | 'stopped' | 'error' |
      'paused';

      =======

      export type Status = 'monitoring' | 'running' | 'stopped' | 'error' |
      'paused';


      export type ConnectionStatus =
        | 'connecting'
        | 'connected'
        | 'disconnected'
        | 'invalidated';
      >>>>>>> REPLACE

      <<<<<<< SEARCH

      export interface IndicatorProps {
        currentTabState: TabState;
        allTabsState: GlobalState;
        onPauseResume: () => void;
        onClose: () => void;
        onNavigate: (tabId: number, windowId: number) => void;
      }

      =======

      export interface IndicatorProps {
        currentTabState: TabState;
        allTabsState: GlobalState;
        connectionStatus: ConnectionStatus;
        onPauseResume: () => void;
        onClose: () => void;
        onNavigate: (tabId: number, windowId: number) => void;
      }

      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: src/content/constants.ts
    content: |-
      <<<<<<< SEARCH
      import type { Status } from '../types';

      export const statusConfig: Record<
      =======
      import type { Status, ConnectionStatus } from '../types';

      export const statusConfig: Record<
      >>>>>>> REPLACE
      <<<<<<< SEARCH
        paused: {
          bgColor: 'bg-orange-500',
          text: 'Paused',
          animate: false,
        },
      };
      =======
        paused: {
          bgColor: 'bg-orange-500',
          text: 'Paused',
          animate: false,
        },
      };

      export const connectionStatusConfig: Record<
        ConnectionStatus,
        { bgColor: string; text: string; animate: boolean }
      > = {
        connecting: {
          bgColor: 'bg-yellow-500',
          text: 'Connecting...',
          animate: true,
        },
        connected: {
          // This is a placeholder, as 'connected' status will use the run status config.
          bgColor: '',
          text: '',
          animate: false,
        },
        disconnected: {
          bgColor: 'bg-orange-500',
          text: 'Disconnected. Reconnecting...',
          animate: true,
        },
        invalidated: {
          bgColor: 'bg-red-500',
          text: 'Error: Please reload tab',
          animate: false,
        },
      };
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: src/content/App.tsx
    content: |-
      <<<<<<< SEARCH
      import { useState, useEffect, useCallback, useRef } from 'react';
      import Indicator from './Indicator';
      import type { GlobalState } from '../types';
      =======
      import { useState, useEffect, useCallback, useRef } from 'react';
      import Indicator from './Indicator';
      import type { GlobalState, ConnectionStatus } from '../types';
      >>>>>>> REPLACE
      <<<<<<< SEARCH
      function App() {
        const [tabId, setTabId] = useState<number | null>(null);
        const [globalState, setGlobalState] = useState<GlobalState>({});
        const lastKnownStopButtonState = useRef<boolean>(false);
        const portRef = useRef<chrome.runtime.Port | null>(null);

        useEffect(() => {
      =======
      function App() {
        const [tabId, setTabId] = useState<number | null>(null);
        const [globalState, setGlobalState] = useState<GlobalState>({});
        const [connectionStatus, setConnectionStatus] =
          useState<ConnectionStatus>('connecting');
        const lastKnownStopButtonState = useRef<boolean>(false);
        const portRef = useRef<chrome.runtime.Port | null>(null);

        useEffect(() => {
      >>>>>>> REPLACE
      <<<<<<< SEARCH
          function connect() {
            // Don't try to connect if the context is known to be invalid
            if (isInvalidated) return;

            try {
              // Accessing chrome.runtime.id will throw if context is invalidated
              if (!chrome.runtime?.id) {
                isInvalidated = true;
                console.error(
                  'AI Studio Notifier: Extension context invalidated. Cannot connect.'
                );
                return;
              }

              port = chrome.runtime.connect({ name: 'content-script' });
              portRef.current = port;

              port.onMessage.addListener((message: any) => {
                if (message.type === 'init') {
                  setTabId(message.tabId);
                  setGlobalState(message.state);
                } else if (message.type === 'stateUpdate') {
                  setGlobalState(message.state);
                }
              });

              port.onDisconnect.addListener(() => {
                portRef.current = null;
                port = null;
                // If the disconnect was not from an invalidated context, try to reconnect.
                if (chrome.runtime?.id) {
                  console.log(
                    'AI Studio Notifier: Port disconnected. Reconnecting in 1s...'
                  );
                  if (reconnectTimeoutId) clearTimeout(reconnectTimeoutId);
                  reconnectTimeoutId = setTimeout(connect, 1000);
                } else {
                  console.error(
                    'AI Studio Notifier: Port disconnected due to invalidated context.'
                  );
                  isInvalidated = true;
                }
              });
            } catch (e) {
              portRef.current = null;
              port = null;
              console.error(
                'AI Studio Notifier: Connection to background script failed:',
                e
              );
              if (e instanceof Error && e.message.includes('context invalidated')) {
                isInvalidated = true;
              } else {
                // Retry connection after a delay if it's not a fatal error
                if (reconnectTimeoutId) clearTimeout(reconnectTimeoutId);
                reconnectTimeoutId = setTimeout(connect, 5000);
              }
            }
          }
      =======
          function connect() {
            // Don't try to connect if the context is known to be invalid
            if (isInvalidated) return;
            setConnectionStatus('connecting');

            try {
              // Accessing chrome.runtime.id will throw if context is invalidated
              if (!chrome.runtime?.id) {
                isInvalidated = true;
                setConnectionStatus('invalidated');
                console.error(
                  'AI Studio Notifier: Extension context invalidated. Cannot connect.'
                );
                return;
              }

              port = chrome.runtime.connect({ name: 'content-script' });
              portRef.current = port;

              port.onMessage.addListener((message: any) => {
                setConnectionStatus('connected');
                if (message.type === 'init') {
                  setTabId(message.tabId);
                  setGlobalState(message.state);
                } else if (message.type === 'stateUpdate') {
                  setGlobalState(message.state);
                }
              });

              port.onDisconnect.addListener(() => {
                portRef.current = null;
                port = null;
                // If the disconnect was not from an invalidated context, try to reconnect.
                if (chrome.runtime?.id) {
                  setConnectionStatus('disconnected');
                  console.log(
                    'AI Studio Notifier: Port disconnected. Reconnecting in 1s...'
                  );
                  if (reconnectTimeoutId) clearTimeout(reconnectTimeoutId);
                  reconnectTimeoutId = setTimeout(connect, 1000);
                } else {
                  setConnectionStatus('invalidated');
                  console.error(
                    'AI Studio Notifier: Port disconnected due to invalidated context.'
                  );
                  isInvalidated = true;
                }
              });
            } catch (e) {
              portRef.current = null;
              port = null;
              console.error(
                'AI Studio Notifier: Connection to background script failed:',
                e
              );
              if (e instanceof Error && e.message.includes('context invalidated')) {
                isInvalidated = true;
                setConnectionStatus('invalidated');
              } else {
                setConnectionStatus('disconnected');
                // Retry connection after a delay if it's not a fatal error
                if (reconnectTimeoutId) clearTimeout(reconnectTimeoutId);
                reconnectTimeoutId = setTimeout(connect, 5000);
              }
            }
          }
      >>>>>>> REPLACE
      <<<<<<< SEARCH
        return (
          <Indicator
            currentTabState={currentTabState}
            allTabsState={globalState}
            onPauseResume={handlePauseResume}
            onClose={handleClose}
            onNavigate={handleNavigate}
          />
        );
      =======
        return (
          <Indicator
            currentTabState={currentTabState}
            allTabsState={globalState}
            connectionStatus={connectionStatus}
            onPauseResume={handlePauseResume}
            onClose={handleClose}
            onNavigate={handleNavigate}
          />
        );
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: src/content/Indicator.tsx
    content: |-
      <<<<<<< SEARCH
      import { useRef, useEffect, useState, useCallback, useMemo } from 'react';
      import { useMovable } from './useMovable';
      import { statusConfig } from './constants';
      import type { IndicatorProps, RunHistoryEntry, TabState } from '../types';
      =======
      import { useRef, useEffect, useState, useCallback, useMemo } from 'react';
      import { useMovable } from './useMovable';
      import { statusConfig, connectionStatusConfig } from './constants';
      import type {
        IndicatorProps,
        RunHistoryEntry,
        TabState,
        ConnectionStatus,
      } from '../types';
      >>>>>>> REPLACE
      <<<<<<< SEARCH
      function Indicator({
        currentTabState,
        allTabsState,
        onPauseResume,
        onClose,
        onNavigate,
      }: IndicatorProps) {
      =======
      function Indicator({
        currentTabState,
        allTabsState,
        connectionStatus,
        onPauseResume,
        onClose,
        onNavigate,
      }: IndicatorProps) {
      >>>>>>> REPLACE
      <<<<<<< SEARCH
        const config = statusConfig[currentTabState.status];
        const isPausable =
          currentTabState.status === 'running' ||
          currentTabState.status === 'paused' ||
          currentTabState.status === 'monitoring';
      =======
        const isConnected = connectionStatus === 'connected';

        const config = isConnected
          ? statusConfig[currentTabState.status]
          : connectionStatusConfig[connectionStatus];

        const isPausable =
          isConnected &&
          (currentTabState.status === 'running' ||
            currentTabState.status === 'paused' ||
            currentTabState.status === 'monitoring');
      >>>>>>> REPLACE
      <<<<<<< SEARCH
            onMouseMove={handleMouseMoveForCursor}
          >
            <div className="drag-handle flex items-center gap-3 p-2 cursor-grab flex-shrink-0">
              <div className="flex items-center gap-2 flex-grow min-w-0">
                <span
                  className={`w-3 h-3 rounded-full flex-shrink-0 ${
                    config.bgColor
                  } ${config.animate ? 'animate-pulse' : ''}`}
                ></span>
                <span className="text-sm font-medium truncate">
                  {currentTabState.runName
                    ? currentTabState.runName
                    : config.text}
                </span>
                {(currentTabState.status === 'running' ||
                  currentTabState.status === 'paused' ||
                  currentTabState.status === 'stopped') && (
                  <span className="text-sm font-mono text-gray-300">
                    {formatElapsedTime(currentTabState.elapsedTime)}
                  </span>
                )}
              </div>
              <div className="flex items-center flex-shrink-0">
                {isPausable && (
                  <button
                    onMouseDown={(e) => e.stopPropagation()}
                    onClick={onPauseResume}
      =======
            onMouseMove={handleMouseMoveForCursor}
          >
            <div className="drag-handle flex items-center gap-3 p-2 cursor-grab flex-shrink-0">
              <div className="flex items-center gap-2 flex-grow min-w-0">
                <span
                  className={`w-3 h-3 rounded-full flex-shrink-0 ${
                    config.bgColor
                  } ${config.animate ? 'animate-pulse' : ''}`}
                ></span>
                <span className="text-sm font-medium truncate">
                  {isConnected
                    ? currentTabState.runName
                      ? currentTabState.runName
                      : config.text
                    : config.text}
                </span>
                {isConnected &&
                  (currentTabState.status === 'running' ||
                    currentTabState.status === 'paused' ||
                    currentTabState.status === 'stopped') && (
                    <span className="text-sm font-mono text-gray-300">
                      {formatElapsedTime(currentTabState.elapsedTime)}
                    </span>
                  )}
              </div>
              <div className="flex items-center flex-shrink-0">
                {isPausable && (
                  <button
                    onMouseDown={(e) => e.stopPropagation()}
                    onClick={onPauseResume}
      >>>>>>> REPLACE
      <<<<<<< SEARCH
            {currentTabState.status === 'error' && currentTabState.error && (
              <p className="text-xs text-red-400 px-2 pb-2 -mt-1">
                {currentTabState.error}
              </p>
            )}

            {/* Expanded History View */}
            {isExpanded && (
              <>
                <div className="flex-grow flex border-t border-white/20 min-h-0">
                  {/* Sidebar */}
      =======
            {isConnected &&
              currentTabState.status === 'error' &&
              currentTabState.error && (
                <p className="text-xs text-red-400 px-2 pb-2 -mt-1">
                  {currentTabState.error}
                </p>
              )}

            {/* Expanded History View */}
            {isConnected && isExpanded && (
              <>
                <div className="flex-grow flex border-t border-white/20 min-h-0">
                  {/* Sidebar */}
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
snapshot:
  src/content/Indicator.tsx: |-
    import { useRef, useEffect, useState, useCallback, useMemo } from 'react';
    import { useMovable } from './useMovable';
    import { statusConfig } from './constants';
    import type { IndicatorProps, RunHistoryEntry, TabState } from '../types';

    function formatElapsedTime(ms: number): string {
      if (ms <= 0) return '00:00';
      const totalSeconds = Math.floor(ms / 1000);
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = totalSeconds % 60;
      const paddedMinutes = String(minutes).padStart(2, '0');
      const paddedSeconds = String(seconds).padStart(2, '0');
      return `${paddedMinutes}:${paddedSeconds}`;
    }

    function HistoryEntry({
      entry,
      onNavigate,
    }: {
      entry: RunHistoryEntry;
      onNavigate: () => void;
    }) {
      return (
        <button
          className="flex items-center justify-between text-xs w-full px-2 py-1 hover:bg-white/10 rounded text-left"
          onClick={onNavigate}
        >
          <div className="flex items-center gap-2 min-w-0">
            <span
              className={`truncate font-mono ${
                entry.status === 'stopped' ? 'text-green-400' : 'text-red-400'
              }`}
            >
              {new Date(entry.endTime).toLocaleString(undefined, {
                year: '2-digit',
                month: 'numeric',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit',
              })}
            </span>
          </div>
          <span className="font-mono text-gray-400 pl-2">
            {formatElapsedTime(entry.durationMs)}
          </span>
        </button>
      );
    }

    const SIDEBAR_WIDTH_STORAGE_KEY = 'indicator-sidebar-width';
    const MIN_SIDEBAR_WIDTH = 100;
    const MIN_CONTENT_WIDTH = 200;

    function Indicator({
      currentTabState,
      allTabsState,
      onPauseResume,
      onClose,
      onNavigate,
    }: IndicatorProps) {
      const indicatorRef = useRef<HTMLDivElement>(null);
      const [isExpanded, setIsExpanded] = useState(false);
      const [selectedTabIdForHistory, setSelectedTabIdForHistory] =
        useState<number | null>(null);
      const [sidebarWidth, setSidebarWidth] = useState(160);

      const sidebarWidthRef = useRef(sidebarWidth);
      useEffect(() => {
        sidebarWidthRef.current = sidebarWidth;
      }, [sidebarWidth]);

      useEffect(() => {
        chrome.storage.local.get(SIDEBAR_WIDTH_STORAGE_KEY, (result) => {
          if (
            result[SIDEBAR_WIDTH_STORAGE_KEY] &&
            typeof result[SIDEBAR_WIDTH_STORAGE_KEY] === 'number'
          ) {
            setSidebarWidth(result[SIDEBAR_WIDTH_STORAGE_KEY]);
          }
        });
      }, []);

      const historyTabs = useMemo<TabState[]>(
        () =>
          Object.values(allTabsState)
            .filter((tab) => tab.history.length > 0)
            .sort((a, b) => {
              const aLast = a.history[0]?.endTime ?? 0;
              const bLast = b.history[0]?.endTime ?? 0;
              return bLast - aLast;
            }),
        [allTabsState]
      );

      useEffect(() => {
        if (isExpanded) {
          const isSelectionValid = historyTabs.some(
            (t) => t.tabId === selectedTabIdForHistory
          );

          if (!isSelectionValid) {
            if (historyTabs.find((t) => t.tabId === currentTabState.tabId)) {
              setSelectedTabIdForHistory(currentTabState.tabId);
            } else if (historyTabs.length > 0) {
              setSelectedTabIdForHistory(historyTabs[0].tabId);
            } else {
              // No history, so collapse
              setIsExpanded(false);
            }
          }
        } else {
          setSelectedTabIdForHistory(null);
        }
      }, [isExpanded, historyTabs, currentTabState.tabId, selectedTabIdForHistory]);

      const handleToggleExpand = useCallback(() => {
        // Only allow expanding if there is history to show
        if (historyTabs.length > 0) {
          setIsExpanded((expanded) => !expanded);
        }
      }, [historyTabs]);

      const { position, size, handleMouseDown, handleMouseMoveForCursor } =
        useMovable(indicatorRef, {
          onDragHandleClick: handleToggleExpand,
          isResizable: isExpanded,
          dragHandleClassName: 'drag-handle',
          initialSize: { width: 550, height: 400 },
          minSize: {
            width: MIN_SIDEBAR_WIDTH + MIN_CONTENT_WIDTH + 6, // 6px for resizer
            height: 250,
          },
        });
      const audioRef = useRef<HTMLAudioElement | null>(null);

      const handleMouseDownResizeSidebar = useCallback((e: React.MouseEvent) => {
        e.preventDefault();
        e.stopPropagation();

        const startX = e.clientX;
        const startWidth = sidebarWidthRef.current;

        const handleMouseMove = (moveEvent: MouseEvent) => {
          const totalWidth =
            indicatorRef.current?.getBoundingClientRect().width ?? 0;
          const dx = moveEvent.clientX - startX;
          let newWidth = startWidth + dx;

          if (newWidth < MIN_SIDEBAR_WIDTH) {
            newWidth = MIN_SIDEBAR_WIDTH;
          }
          if (totalWidth && newWidth > totalWidth - MIN_CONTENT_WIDTH - 6) {
            // 6px for resizer
            newWidth = totalWidth - MIN_CONTENT_WIDTH - 6;
          }
          setSidebarWidth(newWidth);
        };

        const handleMouseUp = () => {
          document.removeEventListener('mousemove', handleMouseMove);
          document.removeEventListener('mouseup', handleMouseUp);
          chrome.storage.local.set({
            [SIDEBAR_WIDTH_STORAGE_KEY]: sidebarWidthRef.current,
          });
        };

        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', handleMouseUp);
      }, []);

      useEffect(() => {
        // Preload audio element when component mounts
        const soundUrl = chrome.runtime.getURL('notification.mp3');
        audioRef.current = new Audio(soundUrl);
      }, []);

      useEffect(() => {
        if (currentTabState?.status === 'stopped') {
          audioRef.current
            ?.play()
            .catch((err) => console.error('Audio play failed: ', err));
        }
      }, [currentTabState?.status]);

      if (!currentTabState) {
        return null;
      }

      const config = statusConfig[currentTabState.status];
      const isPausable =
        currentTabState.status === 'running' ||
        currentTabState.status === 'paused' ||
        currentTabState.status === 'monitoring';

      const totalRuns = historyTabs.reduce(
        (sum, tab) => sum + tab.history.length,
        0
      );
      const totalDuration = historyTabs.reduce(
        (sum: number, tab: TabState) =>
          sum +
          tab.history.reduce(
            (tabSum: number, run: RunHistoryEntry) => tabSum + run.durationMs,
            0
          ),
        0
      );
      const avgDuration = totalRuns > 0 ? totalDuration / totalRuns : 0;

      return (
        <div
          ref={indicatorRef}
          className="fixed top-0 left-0 z-[99999] rounded-lg shadow-lg text-white font-sans select-none flex flex-col"
          style={{
            transform: `translate3d(${position.x}px, ${position.y}px, 0)`,
            backgroundColor: 'rgba(20, 20, 20, 0.8)',
            backdropFilter: 'blur(4px)',
            width: isExpanded ? `${size.width}px` : '256px',
            height: isExpanded ? `${size.height}px` : 'auto',
          }}
          onMouseDown={handleMouseDown}
          onMouseMove={handleMouseMoveForCursor}
        >
          <div className="drag-handle flex items-center gap-3 p-2 cursor-grab flex-shrink-0">
            <div className="flex items-center gap-2 flex-grow min-w-0">
              <span
                className={`w-3 h-3 rounded-full flex-shrink-0 ${
                  config.bgColor
                } ${config.animate ? 'animate-pulse' : ''}`}
              ></span>
              <span className="text-sm font-medium truncate">
                {currentTabState.runName
                  ? currentTabState.runName
                  : config.text}
              </span>
              {(currentTabState.status === 'running' ||
                currentTabState.status === 'paused' ||
                currentTabState.status === 'stopped') && (
                <span className="text-sm font-mono text-gray-300">
                  {formatElapsedTime(currentTabState.elapsedTime)}
                </span>
              )}
            </div>
            <div className="flex items-center flex-shrink-0">
              {isPausable && (
                <button
                  onMouseDown={(e) => e.stopPropagation()}
                  onClick={onPauseResume}
                  className="text-gray-400 hover:text-white cursor-pointer p-1 rounded-full"
                  title={currentTabState.status === 'paused' ? 'Resume' : 'Pause'}
                >
                  {currentTabState.status === 'running' ||
                  currentTabState.status === 'monitoring' ? (
                    <svg
                      xmlns="http://www.w3.org/2000/svg"
                      width="12"
                      height="12"
                      viewBox="0 0 24 24"
                      fill="currentColor"
                      className="block"
                    >
                      <path d="M14 19h4V5h-4v14zm-8 0h4V5H6v14z" />
                    </svg>
                  ) : (
                    <svg
                      xmlns="http://www.w3.org/2000/svg"
                      width="12"
                      height="12"
                      viewBox="0 0 24 24"
                      fill="currentColor"
                      className="block"
                    >
                      <path d="M8 5v14l11-7z" />
                    </svg>
                  )}
                </button>
              )}
              <button
                onMouseDown={(e) => e.stopPropagation()}
                onClick={onClose}
                className="text-gray-400 hover:text-white cursor-pointer p-1 rounded-full"
                title="Hide Indicator"
              >
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  width="12"
                  height="12"
                  viewBox="0 0 24 24"
                  fill="currentColor"
                  className="block"
                >
                  <path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z" />
                </svg>
              </button>
            </div>
          </div>
          {currentTabState.status === 'error' && currentTabState.error && (
            <p className="text-xs text-red-400 px-2 pb-2 -mt-1">
              {currentTabState.error}
            </p>
          )}

          {/* Expanded History View */}
          {isExpanded && (
            <>
              <div className="flex-grow flex border-t border-white/20 min-h-0">
                {/* Sidebar */}
                <div
                  className="overflow-y-auto flex-shrink-0 flex flex-col py-1"
                  style={{ width: `${sidebarWidth}px` }}
                >
                  {historyTabs.map((tab) => {
                    const tabDisplayName =
                      tab.history[0]?.runName || `Tab ${tab.tabId}`;
                    const isSelected = selectedTabIdForHistory === tab.tabId;
                    return (
                      <button
                        key={tab.tabId}
                        onClick={(e) => {
                          if (e.ctrlKey || e.metaKey) {
                            onNavigate(tab.tabId, tab.windowId);
                            e.preventDefault();
                          } else {
                            setSelectedTabIdForHistory(tab.tabId);
                          }
                        }}
                        className={`w-full text-left p-2 text-xs ${
                          isSelected ? 'bg-white/10' : 'hover:bg-white/5'
                        }`}
                        title={`${tabDisplayName}\n(Ctrl+Click to go to tab)`}
                      >
                        <div className="flex items-center gap-2 font-bold text-gray-200">
                          <span
                            className={`w-2 h-2 rounded-full flex-shrink-0 ${
                              statusConfig[tab.status].bgColor
                            } ${
                              statusConfig[tab.status].animate
                                ? 'animate-pulse'
                                : ''
                            }`}
                          ></span>
                          <span className="truncate">{tabDisplayName}</span>
                        </div>
                        <div className="text-gray-400 pl-4">
                          {tab.history.length} run
                          {tab.history.length !== 1 ? 's' : ''}
                        </div>
                      </button>
                    );
                  })}
                </div>

                {/* Resizer */}
                <div
                  onMouseDown={handleMouseDownResizeSidebar}
                  className="w-1.5 flex-shrink-0 cursor-col-resize bg-white/10 hover:bg-white/20 transition-colors"
                ></div>

                {/* Main Content */}
                <div className="flex-grow overflow-y-auto">
                  {(() => {
                    const selectedTabData = selectedTabIdForHistory
                      ? allTabsState[selectedTabIdForHistory]
                      : null;

                    if (!selectedTabData) {
                      return (
                        <p className="text-xs text-gray-400 text-center py-4">
                          Select a tab to view its history.
                        </p>
                      );
                    }

                    return (
                      <div className="flex flex-col gap-0.5 p-2">
                        {selectedTabData.history.map((entry) => (
                          <HistoryEntry
                            key={entry.id}
                            entry={entry}
                            onNavigate={() =>
                              onNavigate(
                                selectedTabData.tabId,
                                selectedTabData.windowId
                              )
                            }
                          />
                        ))}
                      </div>
                    );
                  })()}
                </div>
              </div>
              {historyTabs.length > 0 ? (
                <div className="flex-shrink-0 text-xs text-gray-400 px-3 py-1.5 border-t border-white/20 flex justify-between">
                  <span>
                    Total Runs:{' '}
                    <span className="font-medium text-gray-300">{totalRuns}</span>
                  </span>
                  <span>
                    Avg:{' '}
                    <span className="font-mono font-medium text-gray-300">
                      {formatElapsedTime(avgDuration)}
                    </span>
                  </span>
                </div>
              ) : null}
            </>
          )}
        </div>
      );
    }

    export default Indicator;
  src/content/App.tsx: |-
    import { useState, useEffect, useCallback, useRef } from 'react';
    import Indicator from './Indicator';
    import type { GlobalState } from '../types';

    /**
     * Captures the current tab's title to use as the run name.
     * This makes notifications more informative.
     * @returns The tab's title, or null if it's empty.
     */
    function captureRunContext(): string | null {
      try {
        const title = document.title?.trim();
        if (title) {
          // Clean up the title, e.g., remove " - Google AI Studio"
          return title.replace(/ - Google AI Studio$/, '').trim();
        }
      } catch (e) {
        console.error(
          'AI Studio Notifier: Error capturing run context from tab title.',
          e
        );
      }
      return null;
    }

    function App() {
      const [tabId, setTabId] = useState<number | null>(null);
      const [globalState, setGlobalState] = useState<GlobalState>({});
      const lastKnownStopButtonState = useRef<boolean>(false);
      const portRef = useRef<chrome.runtime.Port | null>(null);

      useEffect(() => {
        let port: chrome.runtime.Port | null = null;
        let isInvalidated = false;
        let reconnectTimeoutId: number | undefined;

        function connect() {
          // Don't try to connect if the context is known to be invalid
          if (isInvalidated) return;

          try {
            // Accessing chrome.runtime.id will throw if context is invalidated
            if (!chrome.runtime?.id) {
              isInvalidated = true;
              console.error(
                'AI Studio Notifier: Extension context invalidated. Cannot connect.'
              );
              return;
            }

            port = chrome.runtime.connect({ name: 'content-script' });
            portRef.current = port;

            port.onMessage.addListener((message: any) => {
              if (message.type === 'init') {
                setTabId(message.tabId);
                setGlobalState(message.state);
              } else if (message.type === 'stateUpdate') {
                setGlobalState(message.state);
              }
            });

            port.onDisconnect.addListener(() => {
              portRef.current = null;
              port = null;
              // If the disconnect was not from an invalidated context, try to reconnect.
              if (chrome.runtime?.id) {
                console.log(
                  'AI Studio Notifier: Port disconnected. Reconnecting in 1s...'
                );
                if (reconnectTimeoutId) clearTimeout(reconnectTimeoutId);
                reconnectTimeoutId = setTimeout(connect, 1000);
              } else {
                console.error(
                  'AI Studio Notifier: Port disconnected due to invalidated context.'
                );
                isInvalidated = true;
              }
            });
          } catch (e) {
            portRef.current = null;
            port = null;
            console.error(
              'AI Studio Notifier: Connection to background script failed:',
              e
            );
            if (e instanceof Error && e.message.includes('context invalidated')) {
              isInvalidated = true;
            } else {
              // Retry connection after a delay if it's not a fatal error
              if (reconnectTimeoutId) clearTimeout(reconnectTimeoutId);
              reconnectTimeoutId = setTimeout(connect, 5000);
            }
          }
        }

        connect();

        return () => {
          if (reconnectTimeoutId) {
            clearTimeout(reconnectTimeoutId);
          }
          // The port object might be from a previous connect attempt, so check it
          if (port) {
            port.disconnect();
          }
          portRef.current = null;
        };
      }, []); // This effect runs only once on component mount

      const postMessage = useCallback((message: any) => {
        if (!portRef.current) {
          console.error(
            'AI Studio Notifier: Cannot post message, port is not connected. It may be sent after reconnection.'
          );
          return;
        }

        try {
          portRef.current.postMessage(message);
        } catch (e) {
          console.warn(
            'AI Studio Notifier: Could not post message. The port was likely disconnected just now.',
            e
          );
          // The onDisconnect listener will handle reconnection.
        }
      }, []);

      const checkState = useCallback(() => {
        if (!tabId) return;
        const currentTabState = globalState[tabId];
        if (!currentTabState || currentTabState.status === 'paused') {
          return;
        }

        try {
          const stopButtonExists = !!document.querySelector<SVGRectElement>(
            'rect[class*="stoppable-stop"]'
          );
          if (stopButtonExists !== lastKnownStopButtonState.current) {
            lastKnownStopButtonState.current = stopButtonExists;
            if (stopButtonExists) {
              postMessage({ type: 'startRun', runName: captureRunContext() });
            } else {
              postMessage({ type: 'stopRun' });
            }
          }
        } catch (e) {
          console.error('AI Studio Notifier: Error during state check.', e);
          postMessage({ type: 'error', error: 'An error occurred during check.' });
        }
      }, [globalState, tabId, postMessage]);

      useEffect(() => {
        if (!tabId) return;
        const currentTabState = globalState[tabId];
        if (currentTabState?.status === 'paused') {
          return;
        }

        const timeoutId = setTimeout(checkState, 1000);
        const observer = new MutationObserver(checkState);
        observer.observe(document.body, { childList: true, subtree: true });

        return () => {
          clearTimeout(timeoutId);
          observer.disconnect();
        };
      }, [checkState, tabId, globalState]);

      const handlePauseResume = useCallback(
        () => postMessage({ type: 'pauseResume' }),
        [postMessage]
      );
      const handleClose = useCallback(
        () => postMessage({ type: 'closeIndicator' }),
        [postMessage]
      );
      const handleNavigate = useCallback(
        (navTabId: number, windowId: number) => {
          postMessage({ type: 'navigateToTab', tabId: navTabId, windowId });
        },
        [postMessage]
      );

      if (!tabId || !globalState[tabId]?.isVisible) {
        return null;
      }

      const currentTabState = globalState[tabId];
      if (!currentTabState) return null; // Should not happen if tabId is set

      return (
        <Indicator
          currentTabState={currentTabState}
          allTabsState={globalState}
          onPauseResume={handlePauseResume}
          onClose={handleClose}
          onNavigate={handleNavigate}
        />
      );
    }

    export default App;
  src/content/constants.ts: |-
    import type { Status } from '../types';

    export const statusConfig: Record<
      Status,
      { bgColor: string; text: string; animate: boolean }
    > = {
      monitoring: {
        bgColor: 'bg-blue-500',
        text: 'Monitoring',
        animate: false,
      },
      running: {
        bgColor: 'bg-green-500',
        text: 'Process Running',
        animate: true,
      },
      stopped: {
        bgColor: 'bg-yellow-500',
        text: 'Process Finished!',
        animate: false,
      },
      error: {
        bgColor: 'bg-red-500',
        text: 'Error!',
        animate: false,
      },
      paused: {
        bgColor: 'bg-orange-500',
        text: 'Paused',
        animate: false,
      },
    };
  src/types.ts: >-
    export type Status = 'monitoring' | 'running' | 'stopped' | 'error' |
    'paused';


    export interface RunHistoryEntry {
      id: string;
      runName: string | null;
      durationMs: number;
      status: 'stopped' | 'error';
      endTime: number;
    }


    export interface TabState {
      tabId: number;
      windowId: number;
      status: Status;
      runName: string | null;
      startTime: number | null;
      elapsedTime: number;
      pausedTime: number;
      pauseStartTime: number | null;
      history: RunHistoryEntry[];
      error: string | null;
      isVisible: boolean; // To control indicator visibility per tab
    }


    export interface GlobalState {
      [tabId: number]: TabState;
    }


    export interface MessageBase {
      type: string;
    }


    export interface InitMessage extends MessageBase {
        type: 'init';
        tabId: number;
        state: GlobalState;
    }


    export interface StateUpdateMessage extends MessageBase {
        type: 'stateUpdate';
        state: GlobalState;
    }


    export interface StartRunMessage extends MessageBase {
        type: 'startRun';
        runName: string | null;
    }


    export interface StopRunMessage extends MessageBase {
        type: 'stopRun';
        isError?: boolean;
        error?: string;
    }


    export interface PauseResumeMessage extends MessageBase {
        type: 'pauseResume';
    }


    export interface CloseIndicatorMessage extends MessageBase {
        type: 'closeIndicator';
    }


    export interface NavigateToTabMessage extends MessageBase {
        type: 'navigateToTab';
        tabId: number;
        windowId: number;
    }


    export interface ErrorMessage extends MessageBase {
        type: 'error';
        error: string;
    }



    // Union type for messages

    export type Message =
      | InitMessage
      | StateUpdateMessage
      | StartRunMessage
      | StopRunMessage
      | PauseResumeMessage
      | CloseIndicatorMessage
      | NavigateToTabMessage
      | ErrorMessage;


    export interface NotificationContext {
      tabId: number;
      windowId: number;
      durationMs?: number | null;
      runName?: string | null;
    }


    export interface IndicatorProps {
      currentTabState: TabState;
      allTabsState: GlobalState;
      onPauseResume: () => void;
      onClose: () => void;
      onNavigate: (tabId: number, windowId: number) => void;
    }
approved: true
