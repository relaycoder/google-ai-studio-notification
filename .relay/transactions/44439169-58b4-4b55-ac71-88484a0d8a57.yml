uuid: 44439169-58b4-4b55-ac71-88484a0d8a57
projectId: google-ai-studio-notification
createdAt: '2025-08-06T21:45:14.012Z'
linesAdded: 44
linesRemoved: 55
gitCommitMsg: 'refactor: Embed site config to fix content script activation'
promptSummary: >-
  The floating indicator is not appearing after implementing `sites.json` logic.
  I suspect the content script is failing to fetch or process this file,
  preventing the indicator from being triggered.
reasoning:
  - >-
    Based on your report that the floating indicator is not being triggered, the
    most likely cause is an issue with loading `sites.json` from the content
    script. This can happen if the file isn't correctly listed in the
    extension's `web_accessible_resources` in `manifest.json`, preventing the
    `fetch` call from succeeding.
  - >-
    To resolve this and make the logic more robust, I'll perform the following
    changes:
  - >-
    1.  I will move the site definitions from `public/sites.json` into a new
    TypeScript file, `src/content/sites.ts`.
  - >-
    2.  I'll modify `src/content/App.tsx` to import this new `sites.ts` module
    directly, completely removing the asynchronous `fetch` call. This ensures
    the site list is always available when the script runs.
  - 3.  Finally, I will delete the now-redundant `public/sites.json` file.
  - >-
    This approach eliminates potential file access and timing issues, ensuring
    the site matching logic runs reliably as soon as the content script is
    injected.
  - First, I'll create the new `sites.ts` file to hold our site configurations.
  - >-
    Next, I'll update `App.tsx` to use this new local module instead of fetching
    the JSON file.
  - Finally, I'll remove the now-unused `sites.json` file.
operations:
  - type: write
    path: src/content/sites.ts
    content: |-
      export interface Site {
        name: string;
        matches: string[];
        selector: string;
      }

      export const sites: Site[] = [
        {
          name: 'Google AI Studio',
          matches: ['https://aistudio.google.com/*'],
          selector: "rect[class*='stoppable-stop']",
        },
        {
          name: 'Kimi Chat',
          matches: ['https://www.kimi.com/chat/*'],
          selector: "svg[name='stop']",
        },
        {
          name: 'Qwen Chat',
          matches: ['https://chat.qwen.ai/c/*'],
          selector: "button > span[aria-label='stop']",
        },
      ];
    patchStrategy: replace
  - type: write
    path: src/content/App.tsx
    content: |-
      <<<<<<< SEARCH
      import Indicator from './Indicator';
      import type { GlobalState, ConnectionStatus } from '../types';
      =======
      import Indicator from './Indicator';
      import { sites } from './sites';
      import type { GlobalState, ConnectionStatus } from '../types';
      >>>>>>> REPLACE
      <<<<<<< SEARCH
        useEffect(() => {
          fetch(chrome.runtime.getURL('sites.json'))
            .then((response) => {
              if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
              }
              return response.json();
            })
            .then((sites: { matches: string[]; selector: string }[]) => {
              const currentUrl = window.location.href;
              const matchedSite = sites.find((site) =>
                site.matches.some((pattern) => {
                  // Simple wildcard to regex conversion.
                  // e.g. "https://*.example.com/*" becomes /^https:\/\/.*\.example\.com\/.*$/
                  const regex = new RegExp(
                    '^' +
                      pattern
                        .replace(/[.+?^${}()|[\]\\]/g, '\\$&')
                        .replace(/\*/g, '.*') +
                      '$'
                  );
                  return regex.test(currentUrl);
                })
              );

              if (matchedSite) {
                setActiveSiteSelector(matchedSite.selector);
              } else {
                // If no site matches, this content script does nothing.
                // console.log('AI Studio Notifier: Current site not supported.');
              }
            })
            .catch((error) =>
              console.error('AI Studio Notifier: Error loading sites.json', error)
            );
        }, []);
      =======
        useEffect(() => {
          const currentUrl = window.location.href;
          const matchedSite = sites.find((site) =>
            site.matches.some((pattern) => {
              // Simple wildcard to regex conversion.
              // e.g. "https://*.example.com/*" becomes /^https:\/\/.*\.example\.com\/.*$/
              const regex = new RegExp(
                '^' +
                  pattern
                    .replace(/[.+?^${}()|[\]\\]/g, '\\$&')
                    .replace(/\*/g, '.*') +
                  '$'
              );
              return regex.test(currentUrl);
            })
          );

          if (matchedSite) {
            setActiveSiteSelector(matchedSite.selector);
          } else {
            // If no site matches, this content script does nothing.
            // console.log('AI Studio Notifier: Current site not supported.');
          }
        }, []);
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: delete
    path: public/sites.json
snapshot:
  src/content/sites.ts: null
  src/content/App.tsx: |-
    import { useState, useEffect, useCallback, useRef } from 'react';
    import Indicator from './Indicator';
    import type { GlobalState, ConnectionStatus } from '../types';

    /**
     * Captures the current tab's title to use as the run name.
     * This makes notifications more informative.
     * @returns The tab's title, or null if it's empty.
     */
    function captureRunContext(): string | null {
      try {
        const title = document.title?.trim();
        if (title) {
          // Clean up the title, e.g., remove " - Google AI Studio"
          return title.replace(/ - Google AI Studio$/, '').trim();
        }
      } catch (e) {
        console.error(
          'AI Studio Notifier: Error capturing run context from tab title.',
          e
        );
      }
      return null;
    }

    function App() {
      const [tabId, setTabId] = useState<number | null>(null);
      const [globalState, setGlobalState] = useState<GlobalState>({});
      const [connectionStatus, setConnectionStatus] =
        useState<ConnectionStatus>('connecting');
      const lastKnownStopButtonState = useRef<boolean>(false);
      const portRef = useRef<chrome.runtime.Port | null>(null);
      const [activeSiteSelector, setActiveSiteSelector] = useState<string | null>(
        null
      );

      useEffect(() => {
        fetch(chrome.runtime.getURL('sites.json'))
          .then((response) => {
            if (!response.ok) {
              throw new Error(`HTTP error! status: ${response.status}`);
            }
            return response.json();
          })
          .then((sites: { matches: string[]; selector: string }[]) => {
            const currentUrl = window.location.href;
            const matchedSite = sites.find((site) =>
              site.matches.some((pattern) => {
                // Simple wildcard to regex conversion.
                // e.g. "https://*.example.com/*" becomes /^https:\/\/.*\.example\.com\/.*$/
                const regex = new RegExp(
                  '^' +
                    pattern
                      .replace(/[.+?^${}()|[\]\\]/g, '\\$&')
                      .replace(/\*/g, '.*') +
                    '$'
                );
                return regex.test(currentUrl);
              })
            );

            if (matchedSite) {
              setActiveSiteSelector(matchedSite.selector);
            } else {
              // If no site matches, this content script does nothing.
              // console.log('AI Studio Notifier: Current site not supported.');
            }
          })
          .catch((error) =>
            console.error('AI Studio Notifier: Error loading sites.json', error)
          );
      }, []);

      useEffect(() => {
        if (!activeSiteSelector) {
          return; // Do nothing if on an unsupported site.
        }

        let port: chrome.runtime.Port | null = null;
        let isInvalidated = false;
        let reconnectTimeoutId: number | undefined;

        function connect() {
          // Don't try to connect if the context is known to be invalid
          if (isInvalidated) return;
          setConnectionStatus('connecting');

          try {
            // Accessing chrome.runtime.id will throw if context is invalidated
            if (!chrome.runtime?.id) {
              isInvalidated = true;
              setConnectionStatus('invalidated');
              console.error(
                'AI Studio Notifier: Extension context invalidated. Cannot connect.'
              );
              return;
            }

            port = chrome.runtime.connect({ name: 'content-script' });
            portRef.current = port;

            port.onMessage.addListener((message: any) => {
              setConnectionStatus('connected');
              if (message.type === 'init') {
                setTabId(message.tabId);
                setGlobalState(message.state);
              } else if (message.type === 'stateUpdate') {
                setGlobalState(message.state);
              }
            });

            port.onDisconnect.addListener(() => {
              portRef.current = null;
              port = null;
              // If the disconnect was not from an invalidated context, try to reconnect.
              if (chrome.runtime?.id) {
                setConnectionStatus('disconnected');
                console.log(
                  'AI Studio Notifier: Port disconnected. Reconnecting in 1s...'
                );
                if (reconnectTimeoutId) clearTimeout(reconnectTimeoutId);
                reconnectTimeoutId = setTimeout(connect, 1000);
              } else {
                setConnectionStatus('invalidated');
                console.error(
                  'AI Studio Notifier: Port disconnected due to invalidated context.'
                );
                isInvalidated = true;
              }
            });
          } catch (e) {
            portRef.current = null;
            port = null;
            console.error(
              'AI Studio Notifier: Connection to background script failed:',
              e
            );
            if (e instanceof Error && e.message.includes('context invalidated')) {
              isInvalidated = true;
              setConnectionStatus('invalidated');
            } else {
              setConnectionStatus('disconnected');
              // Retry connection after a delay if it's not a fatal error
              if (reconnectTimeoutId) clearTimeout(reconnectTimeoutId);
              reconnectTimeoutId = setTimeout(connect, 5000);
            }
          }
        }

        connect();

        return () => {
          if (reconnectTimeoutId) {
            clearTimeout(reconnectTimeoutId);
          }
          // The port object might be from a previous connect attempt, so check it
          if (port) {
            port.disconnect();
          }
          portRef.current = null;
        };
      }, [activeSiteSelector]); // This effect now depends on the site being supported

      const postMessage = useCallback((message: any) => {
        if (!portRef.current) {
          console.error(
            'AI Studio Notifier: Cannot post message, port is not connected. It may be sent after reconnection.'
          );
          return;
        }

        try {
          portRef.current.postMessage(message);
        } catch (e) {
          console.warn(
            'AI Studio Notifier: Could not post message. The port was likely disconnected just now.',
            e
          );
          // The onDisconnect listener will handle reconnection.
        }
      }, []);

      const checkState = useCallback(() => {
        if (!tabId || !activeSiteSelector) return;
        const currentTabState = globalState[tabId];
        if (
          !currentTabState ||
          currentTabState.status === 'paused' ||
          currentTabState.status === 'standby'
        ) {
          return;
        }

        try {
          const stopButtonExists = !!document.querySelector(activeSiteSelector);
          if (stopButtonExists !== lastKnownStopButtonState.current) {
            lastKnownStopButtonState.current = stopButtonExists;
            if (stopButtonExists) {
              postMessage({ type: 'startRun', runName: captureRunContext() });
            } else {
              postMessage({ type: 'stopRun' });
            }
          }
        } catch (e) {
          console.error('AI Studio Notifier: Error during state check.', e);
          postMessage({ type: 'error', error: 'An error occurred during check.' });
        }
      }, [globalState, tabId, postMessage, activeSiteSelector]);

      useEffect(() => {
        // Do not run observer if the site is not supported, or tabId is not yet known.
        if (!tabId || !activeSiteSelector) return;

        const currentTabState = globalState[tabId];
        if (
          currentTabState?.status === 'paused' ||
          currentTabState?.status === 'standby'
        ) {
          return;
        }

        const timeoutId = setTimeout(checkState, 1000);
        const observer = new MutationObserver(checkState);
        observer.observe(document.body, { childList: true, subtree: true });

        return () => {
          clearTimeout(timeoutId);
          observer.disconnect();
        };
      }, [checkState, tabId, globalState, activeSiteSelector]);

      const handlePauseResume = useCallback(
        () => postMessage({ type: 'pauseResume' }),
        [postMessage]
      );
      const handleClose = useCallback(
        () => postMessage({ type: 'closeIndicator' }),
        [postMessage]
      );
      const handleNavigate = useCallback(
        (navTabId: number, windowId: number) => {
          postMessage({ type: 'navigateToTab', tabId: navTabId, windowId });
        },
        [postMessage]
      );

      if (!activeSiteSelector || !tabId || !globalState[tabId]?.isVisible) {
        return null;
      }

      const currentTabState = globalState[tabId];
      if (!currentTabState) return null; // Should not happen if tabId is set

      return (
        <Indicator
          currentTabState={currentTabState}
          allTabsState={globalState}
          connectionStatus={connectionStatus}
          onPauseResume={handlePauseResume}
          onClose={handleClose}
          onNavigate={handleNavigate}
        />
      );
    }

    export default App;
  public/sites.json: |-
    [
      {
        "name": "Google AI Studio",
        "matches": [
          "https://aistudio.google.com/*"
        ],
        "selector": "rect[class*='stoppable-stop']"
      },
      {
        "name": "Kimi Chat",
        "matches": [
          "https://www.kimi.com/chat/*"
        ],
        "selector": "svg[name='stop']"
      },
      {
        "name": "Qwen Chat",
        "matches": [
          "https://chat.qwen.ai/c/*"
        ],
        "selector": "button > span[aria-label='stop']"
      }
    ]
approved: true
