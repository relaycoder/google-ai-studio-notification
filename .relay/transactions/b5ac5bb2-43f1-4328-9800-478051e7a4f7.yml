uuid: b5ac5bb2-43f1-4328-9800-478051e7a4f7
projectId: google-ai-studio-notification
createdAt: '2025-08-05T14:21:24.372Z'
linesAdded: 287
linesRemoved: 97
gitCommitMsg: 'refactor(indicator): overhaul UI and implement resizable/movable window'
promptSummary: >-
  The user wants to refactor the UI/UX of the expanded indicator. This includes
  improving the visual design to be more cohesive and enhancing the
  functionality to allow resizing from any edge or corner, both horizontally and
  vertically.
reasoning:
  - >-
    Hello there! I'm anton, your expert AI programmer. I've analyzed your
    request to refactor the indicator's UI/UX, and I've come up with a plan to
    make it more modern, cohesive, and functional. Here are the changes I'll be
    making.
  - '### Plan of Action'
  - >-
    1.  **Introducing `useMovable.ts`**: I'll replace the existing `useDrag.ts`
    hook with a more powerful `useMovable.ts` hook. This new hook encapsulates
    logic for both dragging the component and resizing it from any edge or
    corner when it's in an expanded state.
  - >-
    2.  **Revamping `Indicator.tsx`**: I will completely overhaul the
    `Indicator.tsx` component to:
  - >-
    *   Utilize the new `useMovable` hook for all its positioning, dragging, and
    resizing needs.
  - >-
    *   Implement a cleaner, more cohesive UI using a card-based design with
    better layout management via flexbox.
  - >-
    *   When expanded, the indicator will now feature a scrollable history list,
    and a distinct footer section for summary statistics like total runs and
    average duration.
  - >-
    *   The history view is now more organized, with clear separation between
    different tabs' histories.
  - >-
    *   The entire expanded indicator window will be resizable by dragging any
    of its edges or corners, providing a much-improved user experience over the
    previous bottom-only resize handle.
  - Let's get to coding!
  - >-
    First, I'll rename `useDrag.ts` to `useMovable.ts` to better reflect its new
    capabilities.
  - >-
    Now, I'll replace the content of the newly renamed `useMovable.ts` with the
    new, more powerful hook.
  - >-
    Finally, I'll apply the significant UI and UX refactor to the
    `Indicator.tsx` component.
  - >-
    These changes significantly improve the user experience and modernise the
    look and feel of the indicator. Let me know if you have any other tasks!
operations:
  - type: rename
    from: src/content/useDrag.ts
    to: src/content/useMovable.ts
  - type: write
    path: src/content/useMovable.ts
    content: >-
      import { useState, useCallback, RefObject, useEffect, useRef } from
      'react';


      const POSITION_STORAGE_KEY = 'indicator-position';

      const SIZE_STORAGE_KEY = 'indicator-size';


      interface Position {
        x: number;
        y: number;
      }

      interface Size {
        width: number;
        height: number;
      }

      type Edges = { top: boolean; right: boolean; bottom: boolean; left:
      boolean };


      const EDGE_SENSITIVITY = 8; // px


      export function useMovable(
        ref: RefObject<HTMLElement>,
        options: {
          onDragHandleClick?: () => void;
          isResizable?: boolean;
          initialSize?: Size;
          minSize?: Size;
          dragHandleClassName?: string;
        }
      ) {
        const {
          onDragHandleClick,
          isResizable = false,
          initialSize = { width: 256, height: 300 },
          minSize = { width: 220, height: 150 },
          dragHandleClassName,
        } = options;

        const [position, setPosition] = useState<Position>({
          x: window.innerWidth - (initialSize.width + 20),
          y: 20,
        });
        const [size, setSize] = useState<Size>(initialSize);

        const stateRef = useRef({ position, size });

        useEffect(() => {
          chrome.storage.local.get(
            [POSITION_STORAGE_KEY, SIZE_STORAGE_KEY],
            (result) => {
              const storedPosition = result[POSITION_STORAGE_KEY];
              if (
                storedPosition &&
                typeof storedPosition.x === 'number' &&
                typeof storedPosition.y === 'number'
              ) {
                setPosition(storedPosition);
              }
              const storedSize = result[SIZE_STORAGE_KEY];
              if (
                isResizable &&
                storedSize &&
                typeof storedSize.width === 'number' &&
                typeof storedSize.height === 'number'
              ) {
                setSize(storedSize);
              }
            }
          );
        }, [isResizable]);

        useEffect(() => {
          stateRef.current = { position, size };
        }, [position, size]);

        const getResizeEdges = (
          e: React.MouseEvent<HTMLDivElement>,
          element: HTMLElement
        ): Edges | null => {
          if (!isResizable) return null;
          const rect = element.getBoundingClientRect();
          return {
            top: e.clientY < rect.top + EDGE_SENSITIVITY,
            bottom: e.clientY > rect.bottom - EDGE_SENSITIVITY,
            left: e.clientX < rect.left + EDGE_SENSITIVITY,
            right: e.clientX > rect.right - EDGE_SENSITIVITY,
          };
        };

        const handleMouseDown = useCallback(
          (e: React.MouseEvent<HTMLDivElement>) => {
            // Only for left mouse button
            if (e.button !== 0) return;

            const element = ref.current;
            if (!element) return;

            const isDragHandle = dragHandleClassName
              ? !!(e.target as HTMLElement).closest(`.${dragHandleClassName}`)
              : true;
            const edges = getResizeEdges(e, element);
            const isResizing =
              edges && (edges.top || edges.bottom || edges.left || edges.right);

            if (isResizing && edges) {
              e.preventDefault();
              e.stopPropagation();
              const startMousePos = { x: e.clientX, y: e.clientY };
              const { position: startElementPos, size: startElementSize } =
                stateRef.current;
              let didInteract = false;

              const handleMouseMoveResize = (moveEvent: MouseEvent) => {
                didInteract = true;
                const dx = moveEvent.clientX - startMousePos.x;
                const dy = moveEvent.clientY - startMousePos.y;

                let newWidth = startElementSize.width;
                let newHeight = startElementSize.height;
                let newX = startElementPos.x;
                let newY = startElementPos.y;

                if (edges.right)
                  newWidth = Math.max(minSize.width, startElementSize.width + dx);
                if (edges.left) {
                  const proposedWidth = startElementSize.width - dx;
                  if (proposedWidth >= minSize.width) {
                    newWidth = proposedWidth;
                    newX = startElementPos.x + dx;
                  }
                }
                if (edges.bottom)
                  newHeight = Math.max(minSize.height, startElementSize.height + dy);
                if (edges.top) {
                  const proposedHeight = startElementSize.height - dy;
                  if (proposedHeight >= minSize.height) {
                    newHeight = proposedHeight;
                    newY = startElementPos.y + dy;
                  }
                }

                setPosition({ x: newX, y: newY });
                setSize({ width: newWidth, height: newHeight });
              };

              const handleMouseUpResize = () => {
                document.removeEventListener('mousemove', handleMouseMoveResize);
                document.removeEventListener('mouseup', handleMouseUpResize);
                if (didInteract) {
                  chrome.storage.local.set({
                    [POSITION_STORAGE_KEY]: stateRef.current.position,
                    [SIZE_STORAGE_KEY]: stateRef.current.size,
                  });
                }
              };

              document.addEventListener('mousemove', handleMouseMoveResize);
              document.addEventListener('mouseup', handleMouseUpResize);
            } else if (isDragHandle) {
              e.preventDefault();
              const startMousePos = { x: e.clientX, y: e.clientY };
              const { position: startElementPos } = stateRef.current;
              let didInteract = false;

              const handleMouseMoveDrag = (moveEvent: MouseEvent) => {
                didInteract = true;
                const dx = moveEvent.clientX - startMousePos.x;
                const dy = moveEvent.clientY - startMousePos.y;
                setPosition({
                  x: startElementPos.x + dx,
                  y: startElementPos.y + dy,
                });
              };

              const handleMouseUpDrag = () => {
                document.removeEventListener('mousemove', handleMouseMoveDrag);
                document.removeEventListener('mouseup', handleMouseUpDrag);
                if (didInteract) {
                  chrome.storage.local.set({
                    [POSITION_STORAGE_KEY]: stateRef.current.position,
                  });
                } else if (onDragHandleClick) {
                  onDragHandleClick();
                }
              };

              document.addEventListener('mousemove', handleMouseMoveDrag);
              document.addEventListener('mouseup', handleMouseUpDrag);
            }
          },
          [
            ref,
            isResizable,
            minSize.width,
            minSize.height,
            onDragHandleClick,
            dragHandleClassName,
          ]
        );

        const handleMouseMoveForCursor = useCallback(
          (e: React.MouseEvent<HTMLDivElement>) => {
            if (!isResizable || e.buttons > 0) return;
            const element = ref.current;
            if (!element) return;
            const edges = getResizeEdges(e, element);
            if (!edges) return;

            let cursor = 'auto';
            if (edges.top && edges.left) cursor = 'nwse-resize';
            else if (edges.top && edges.right) cursor = 'nesw-resize';
            else if (edges.bottom && edges.left) cursor = 'nesw-resize';
            else if (edges.bottom && edges.right) cursor = 'nwse-resize';
            else if (edges.left || edges.right) cursor = 'ew-resize';
            else if (edges.top || edges.bottom) cursor = 'ns-resize';

            if (cursor === 'auto') {
              const isDragHandle = dragHandleClassName
                ? !!(e.target as HTMLElement).closest(`.${dragHandleClassName}`)
                : false;
              if (isDragHandle) {
                cursor = 'grab';
              }
            }

            // To avoid flickering, only set cursor if it needs to change
            if (element.style.cursor !== cursor) {
              element.style.cursor = cursor;
            }
          },
          [ref, isResizable, dragHandleClassName]
        );

        return { position, size, handleMouseDown, handleMouseMoveForCursor };
      }
    patchStrategy: replace
  - type: write
    path: src/content/Indicator.tsx
    content: >-
      --- src/content/Indicator.tsx

      +++ src/content/Indicator.tsx

      @@ -1,5 +1,5 @@
       import { useRef, useEffect, useState, useCallback } from 'react';
      -import { useDrag } from './useDrag';

      +import { useMovable } from './useMovable';
       import { statusConfig } from './constants';
       import type { IndicatorProps, RunHistoryEntry, TabState } from '../types';
       
      @@ -16,49 +16,42 @@
         onClick,
       }: {
         entry: RunHistoryEntry;
      -  onClick: () => void;

      +  onNavigate: () => void;
       }) {
         return (
      -    <div

      -      className="flex items-center justify-between text-xs px-2 py-1
      hover:bg-white/10 rounded cursor-pointer"

      -      onClick={onClick}

      -    >

      +    <button

      +      className="flex items-center justify-between text-xs w-full px-2
      py-1 hover:bg-white/10 rounded text-left"

      +      onClick={onNavigate}

      +    >
             <div className="flex items-center gap-2">
      -        <span

      -          className={

      -            entry.status === 'stopped' ? 'text-green-400' :
      'text-red-400'

      -          }

      -        >

      +        <span className={entry.status === 'stopped' ? 'text-green-400' :
      'text-red-400'}>
                 {entry.status === 'stopped' ? '✔' : '✖'}
               </span>
      -        <span className="truncate max-w-[180px] text-gray-300">

      +        <span className="truncate text-gray-300">
                 {entry.runName || 'Untitled Run'}
               </span>
             </div>
      -      <span className="font-mono text-gray-400">

      +      <span className="font-mono text-gray-400 pl-2">
               {formatElapsedTime(entry.durationMs)}
             </span>
      -    </div>

      +    </button>
         );
       }
       
       function TabHistory({
         tabState,
         onNavigate,
      +  isFirst,
       }: {
         tabState: TabState;
         onNavigate: (tabId: number, windowId: number) => void;
      +  isFirst: boolean;
       }) {
         if (tabState.history.length === 0) return null;
       
         return (
      -    <div className="mt-2">

      -      <div

      -        className="text-xs font-bold text-gray-200 px-2 py-1
      cursor-pointer hover:underline truncate"

      -        onClick={() => onNavigate(tabState.tabId, tabState.windowId)}

      -        title={tabState.history[0].runName || `Tab ${tabState.tabId}`}

      -      >

      +    <div className={isFirst ? '' : 'mt-2 border-t border-white/10 pt-2'}>

      +      <button className="text-xs font-bold text-gray-200 px-2 py-1
      cursor-pointer hover:underline truncate w-full text-left" onClick={() =>
      onNavigate(tabState.tabId, tabState.windowId)}
      title={tabState.history[0].runName || `Tab ${tabState.tabId}`}>
               Tab: {tabState.history[0].runName || `Tab ${tabState.tabId}`}
             </div>
             <div className="flex flex-col gap-0.5">
      @@ -66,7 +59,7 @@
                 <HistoryEntry
                   key={entry.id}
                   entry={entry}
      -            onClick={() => onNavigate(tabState.tabId, tabState.windowId)}

      +            onNavigate={() => onNavigate(tabState.tabId,
      tabState.windowId)}
                 />
               ))}
             </div>
      @@ -81,21 +74,21 @@
         onNavigate,
       }: IndicatorProps) {
         const indicatorRef = useRef<HTMLDivElement>(null);
      -  const historyContainerRef = useRef<HTMLDivElement>(null);
         const [isExpanded, setIsExpanded] = useState(false);
      -  const [historyHeight, setHistoryHeight] = useState(240); // default is
      max-h-60 (240px)

      -  const INDICATOR_HEIGHT_KEY = 'indicator-history-height';
       
         const handleToggleExpand = useCallback(() => {
           // Only allow expanding if there is history to show
           if (Object.values(allTabsState).some((tab) => tab.history.length > 0)) {
             setIsExpanded((expanded) => !expanded);
           }
         }, [allTabsState]);
       
      -  const { position, handleMouseDown } = useDrag(indicatorRef,
      handleToggleExpand);

      +  const { position, size, handleMouseDown, handleMouseMoveForCursor } =

      +    useMovable(indicatorRef, {

      +      onDragHandleClick: handleToggleExpand,

      +      isResizable: isExpanded,

      +      dragHandleClassName: 'drag-handle',

      +    });
         const audioRef = useRef<HTMLAudioElement | null>(null);
       
         useEffect(() => {
      -    chrome.storage.local.get(INDICATOR_HEIGHT_KEY, (result) => {

      -      if (result[INDICATOR_HEIGHT_KEY]) {

      -        setHistoryHeight(result[INDICATOR_HEIGHT_KEY]);

      -      }

      -    });
           // Preload audio element when component mounts
           const soundUrl = chrome.runtime.getURL('notification.mp3');
           audioRef.current = new Audio(soundUrl);
      @@ -107,31 +100,6 @@
               ?.play()
               .catch((err) => console.error('Audio play failed: ', err));
           }
         }, [currentTabState?.status]);
      -

      -  const handleResizeMouseDown = useCallback(

      -    (e: React.MouseEvent<HTMLDivElement>) => {

      -      e.preventDefault();

      -      e.stopPropagation(); // Prevent drag-to-move and expand/collapse

      -

      -      const startY = e.clientY;

      -      const startHeight = historyContainerRef.current?.clientHeight ??
      240;

      -

      -      const handleMouseMove = (moveEvent: MouseEvent) => {

      -        const dy = moveEvent.clientY - startY;

      -        const newHeight = Math.max(50, startHeight + dy); // min height
      50px

      -        setHistoryHeight(newHeight);

      -      };

      -

      -      const handleMouseUp = (upEvent: MouseEvent) => {

      -        document.removeEventListener('mousemove', handleMouseMove);

      -        document.removeEventListener('mouseup', handleMouseUp);

      -        const dy = upEvent.clientY - startY;

      -        const newHeight = Math.max(50, startHeight + dy);

      -        chrome.storage.local.set({ [INDICATOR_HEIGHT_KEY]: newHeight });

      -      };

      -

      -      document.addEventListener('mousemove', handleMouseMove);

      -      document.addEventListener('mouseup', handleMouseUp);

      -    },

      -    [] // No dependencies needed, we get startHeight from ref

      -  );
       
         if (!currentTabState) {
           return null;
      @@ -164,17 +132,26 @@
         return (
           <div
             ref={indicatorRef}
      -      className="fixed top-0 left-0 z-[99999] rounded-lg shadow-lg
      text-white font-sans select-none w-64"

      +      className="fixed top-0 left-0 z-[99999] rounded-lg shadow-lg
      text-white font-sans select-none flex flex-col"
             style={{
               transform: `translate3d(${position.x}px, ${position.y}px, 0)`,
               backgroundColor: 'rgba(20, 20, 20, 0.8)',
               backdropFilter: 'blur(4px)',
      +        width: isExpanded ? `${size.width}px` : '256px',

      +        height: isExpanded ? `${size.height}px` : 'auto',
             }}
      +      onMouseDown={handleMouseDown}

      +      onMouseMove={handleMouseMoveForCursor}
           >
             <div
      -        className="flex items-center gap-3 p-2 cursor-grab"

      -        onMouseDown={handleMouseDown}

      +        className="drag-handle flex items-center gap-3 p-2 cursor-grab
      flex-shrink-0"
             >
               <div className="flex items-center gap-2 flex-grow min-w-0">
                 <span
      -            className={`w-3 h-3 rounded-full flex-shrink-0
      ${config.bgColor} ${

      -              config.animate ? 'animate-pulse' : ''

      -            }`}

      +            className={`w-3 h-3 rounded-full flex-shrink-0 ${

      +              config.bgColor

      +            } ${config.animate ? 'animate-pulse' : ''}`}
                 ></span>
                 <span className="text-sm font-medium truncate">
                   {currentTabState.runName
      @@ -249,38 +226,33 @@
       
             {/* Expanded History View */}
             {isExpanded && (
      -        <div

      -          className="p-2 border-t border-white/10"

      -          onMouseDown={(e) => e.stopPropagation()}

      -        >

      +        <>

      +          <div className="flex-grow overflow-y-auto px-2 pt-2 border-t
      border-white/20 min-h-0">

      +            {historyTabs.length > 0 ? (

      +              historyTabs.map((tabState, index) => (

      +                <TabHistory

      +                  key={tabState.tabId}

      +                  tabState={tabState}

      +                  onNavigate={onNavigate}

      +                  isFirst={index === 0}

      +                />

      +              ))

      +            ) : (

      +              <p className="text-xs text-gray-400 text-center py-2">

      +                No completed runs in this session.

      +              </p>

      +            )}

      +          </div>
                 {historyTabs.length > 0 ? (
      -            <>

      -              <div className="flex justify-between items-baseline px-2
      pb-2">

      -                <h3 className="text-sm font-bold">Run History</h3>

      -                <p className="text-xs text-gray-400">

      -                  Avg: {formatElapsedTime(avgDuration)}

      -                </p>

      -              </div>

      -              <div

      -                ref={historyContainerRef}

      -                className="overflow-y-auto pr-1"

      -                style={{ height: `${historyHeight}px` }}

      -              >

      -                {historyTabs.map((tabState) => (

      -                  <TabHistory

      -                    key={tabState.tabId}

      -                    tabState={tabState}

      -                    onNavigate={onNavigate}

      -                  />

      -                ))}

      -              </div>

      -              <div

      -                onMouseDown={handleResizeMouseDown}

      -                className="w-full h-2 cursor-s-resize mt-1 rounded"

      -              ></div>

      -            </>

      -          ) : (

      -            <p className="text-xs text-gray-400 text-center py-2">

      -              No completed runs in this session.

      -            </p>

      +            <div className="flex-shrink-0 text-xs text-gray-400 px-3
      py-1.5 border-t border-white/20 flex justify-between">

      +              <span>

      +                Total Runs: <span className="font-medium
      text-gray-300">{totalRuns}</span>

      +              </span>

      +              <span>

      +                Avg: <span className="font-mono font-medium
      text-gray-300">{formatElapsedTime(avgDuration)}</span>

      +              </span>

      +            </div>
                 )}
      -        </div>

      +        </>
             )}
           </div>
         );
    patchStrategy: new-unified
snapshot:
  src/content/useMovable.ts: null
  src/content/useDrag.ts: |-
    import { useState, useCallback, RefObject, useEffect, useRef } from 'react';

    const STORAGE_KEY = 'indicator-position';

    interface Position {
      x: number;
      y: number;
    }

    export function useDrag(
      ref: RefObject<HTMLElement>,
      onClickWithoutDrag?: () => void
    ) {
      const [position, setPosition] = useState<Position>({
        x: window.innerWidth - 250, // Initial position top-right
        y: 20,
      });
      const positionRef = useRef(position);

      // Load position from storage on initial mount
      useEffect(() => {
        chrome.storage.local.get(STORAGE_KEY, (result) => {
          if (
            result[STORAGE_KEY] &&
            typeof result[STORAGE_KEY].x === 'number' &&
            typeof result[STORAGE_KEY].y === 'number'
          ) {
            setPosition(result[STORAGE_KEY]);
          }
        });
      }, []); // Empty dependency array ensures this runs only once on mount

      // Keep ref in sync with state for access in callbacks
      useEffect(() => {
        positionRef.current = position;
      }, [position]);

      const handleMouseDown = useCallback(
        (e: React.MouseEvent<HTMLDivElement>) => {
          // Prevents text selection while dragging
          e.preventDefault();
          // Only start drag for left mouse button
          if (e.button !== 0) return;

          const startPos = { x: e.clientX, y: e.clientY };
          const elementStartPos = positionRef.current; // Use ref to get position at drag start
          const element = ref.current;
          if (!element) return;
          let didDrag = false;

          const handleMouseMove = (moveEvent: MouseEvent) => {
            didDrag = true; // Any move is a drag
            const dx = moveEvent.clientX - startPos.x;
            const dy = moveEvent.clientY - startPos.y;
            setPosition({
              x: elementStartPos.x + dx,
              y: elementStartPos.y + dy,
            });
          };

          const handleMouseUp = () => {
            document.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);
            if (didDrag) {
              // On mouse up, the drag is over. The `position` state has been updated
              // by the last `handleMouseMove`. The `useEffect` listening to `position`
              // will have updated `positionRef.current`. We can now save it.
              chrome.storage.local.set({ [STORAGE_KEY]: positionRef.current });
            } else if (onClickWithoutDrag) {
              onClickWithoutDrag();
            }
          };

          document.addEventListener('mousemove', handleMouseMove);
          document.addEventListener('mouseup', handleMouseUp);
        },
        [ref, onClickWithoutDrag]
      );

      return {
        position,
        setPosition, // Expose setPosition for potential programmatic updates
        handleMouseDown,
      };
    }
  src/content/Indicator.tsx: |-
    import { useRef, useEffect, useState, useCallback } from 'react';
    import { useDrag } from './useDrag';
    import { statusConfig } from './constants';
    import type { IndicatorProps, RunHistoryEntry, TabState } from '../types';

    function formatElapsedTime(ms: number): string {
      if (ms <= 0) return '00:00';
      const totalSeconds = Math.floor(ms / 1000);
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = totalSeconds % 60;
      const paddedMinutes = String(minutes).padStart(2, '0');
      const paddedSeconds = String(seconds).padStart(2, '0');
      return `${paddedMinutes}:${paddedSeconds}`;
    }

    function HistoryEntry({
      entry,
      onClick,
    }: {
      entry: RunHistoryEntry;
      onClick: () => void;
    }) {
      return (
        <div
          className="flex items-center justify-between text-xs px-2 py-1 hover:bg-white/10 rounded cursor-pointer"
          onClick={onClick}
        >
          <div className="flex items-center gap-2">
            <span
              className={
                entry.status === 'stopped' ? 'text-green-400' : 'text-red-400'
              }
            >
              {entry.status === 'stopped' ? '✔' : '✖'}
            </span>
            <span className="truncate max-w-[180px] text-gray-300">
              {entry.runName || 'Untitled Run'}
            </span>
          </div>
          <span className="font-mono text-gray-400">
            {formatElapsedTime(entry.durationMs)}
          </span>
        </div>
      );
    }

    function TabHistory({
      tabState,
      onNavigate,
    }: {
      tabState: TabState;
      onNavigate: (tabId: number, windowId: number) => void;
    }) {
      if (tabState.history.length === 0) return null;

      return (
        <div className="mt-2">
          <div
            className="text-xs font-bold text-gray-200 px-2 py-1 cursor-pointer hover:underline truncate"
            onClick={() => onNavigate(tabState.tabId, tabState.windowId)}
            title={tabState.history[0].runName || `Tab ${tabState.tabId}`}
          >
            Tab: {tabState.history[0].runName || `Tab ${tabState.tabId}`}
          </div>
          <div className="flex flex-col gap-0.5">
            {tabState.history.map((entry) => (
              <HistoryEntry
                key={entry.id}
                entry={entry}
                onClick={() => onNavigate(tabState.tabId, tabState.windowId)}
              />
            ))}
          </div>
        </div>
      );
    }

    function Indicator({
      currentTabState,
      allTabsState,
      onPauseResume,
      onClose,
      onNavigate,
    }: IndicatorProps) {
      const indicatorRef = useRef<HTMLDivElement>(null);
      const historyContainerRef = useRef<HTMLDivElement>(null);
      const [isExpanded, setIsExpanded] = useState(false);
      const [historyHeight, setHistoryHeight] = useState(240); // default is max-h-60 (240px)
      const INDICATOR_HEIGHT_KEY = 'indicator-history-height';

      const handleToggleExpand = useCallback(() => {
        // Only allow expanding if there is history to show
        if (Object.values(allTabsState).some((tab) => tab.history.length > 0)) {
          setIsExpanded((expanded) => !expanded);
        }
      }, [allTabsState]);

      const { position, handleMouseDown } = useDrag(indicatorRef, handleToggleExpand);
      const audioRef = useRef<HTMLAudioElement | null>(null);

      useEffect(() => {
        chrome.storage.local.get(INDICATOR_HEIGHT_KEY, (result) => {
          if (result[INDICATOR_HEIGHT_KEY]) {
            setHistoryHeight(result[INDICATOR_HEIGHT_KEY]);
          }
        });
        // Preload audio element when component mounts
        const soundUrl = chrome.runtime.getURL('notification.mp3');
        audioRef.current = new Audio(soundUrl);
      }, []);

      useEffect(() => {
        if (currentTabState?.status === 'stopped') {
          audioRef.current
            ?.play()
            .catch((err) => console.error('Audio play failed: ', err));
        }
      }, [currentTabState?.status]);

      const handleResizeMouseDown = useCallback(
        (e: React.MouseEvent<HTMLDivElement>) => {
          e.preventDefault();
          e.stopPropagation(); // Prevent drag-to-move and expand/collapse

          const startY = e.clientY;
          const startHeight = historyContainerRef.current?.clientHeight ?? 240;

          const handleMouseMove = (moveEvent: MouseEvent) => {
            const dy = moveEvent.clientY - startY;
            const newHeight = Math.max(50, startHeight + dy); // min height 50px
            setHistoryHeight(newHeight);
          };

          const handleMouseUp = (upEvent: MouseEvent) => {
            document.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);
            const dy = upEvent.clientY - startY;
            const newHeight = Math.max(50, startHeight + dy);
            chrome.storage.local.set({ [INDICATOR_HEIGHT_KEY]: newHeight });
          };

          document.addEventListener('mousemove', handleMouseMove);
          document.addEventListener('mouseup', handleMouseUp);
        },
        [] // No dependencies needed, we get startHeight from ref
      );

      if (!currentTabState) {
        return null;
      }

      const config = statusConfig[currentTabState.status];
      const isPausable =
        currentTabState.status === 'running' ||
        currentTabState.status === 'paused' ||
        currentTabState.status === 'monitoring';

      const historyTabs = Object.values(allTabsState)
        .filter((tab) => tab.history.length > 0)
        .sort((a, b) => {
          const aLast = a.history[0]?.endTime ?? 0;
          const bLast = b.history[0]?.endTime ?? 0;
          return bLast - aLast;
        });

      const totalRuns = historyTabs.reduce(
        (sum, tab) => sum + tab.history.length,
        0
      );
      const totalDuration = historyTabs.reduce(
        (sum: number, tab: TabState) =>
          sum +
          tab.history.reduce(
            (tabSum: number, run: RunHistoryEntry) => tabSum + run.durationMs,
            0
          ),
        0
      );
      const avgDuration = totalRuns > 0 ? totalDuration / totalRuns : 0;

      return (
        <div
          ref={indicatorRef}
          className="fixed top-0 left-0 z-[99999] rounded-lg shadow-lg text-white font-sans select-none w-64"
          style={{
            transform: `translate3d(${position.x}px, ${position.y}px, 0)`,
            backgroundColor: 'rgba(20, 20, 20, 0.8)',
            backdropFilter: 'blur(4px)',
          }}
        >
          <div
            className="flex items-center gap-3 p-2 cursor-grab"
            onMouseDown={handleMouseDown}
          >
            <div className="flex items-center gap-2 flex-grow min-w-0">
              <span
                className={`w-3 h-3 rounded-full flex-shrink-0 ${config.bgColor} ${
                  config.animate ? 'animate-pulse' : ''
                }`}
              ></span>
              <span className="text-sm font-medium truncate">
                {currentTabState.runName
                  ? currentTabState.runName
                  : config.text}
              </span>
              {(currentTabState.status === 'running' ||
                currentTabState.status === 'paused' ||
                currentTabState.status === 'stopped') && (
                <span className="text-sm font-mono text-gray-300">
                  {formatElapsedTime(currentTabState.elapsedTime)}
                </span>
              )}
            </div>
            <div className="flex items-center flex-shrink-0">
              {isPausable && (
                <button
                  onMouseDown={(e) => e.stopPropagation()}
                  onClick={onPauseResume}
                  className="text-gray-400 hover:text-white cursor-pointer p-1 rounded-full"
                  title={currentTabState.status === 'paused' ? 'Resume' : 'Pause'}
                >
                  {currentTabState.status === 'running' ||
                  currentTabState.status === 'monitoring' ? (
                    <svg
                      xmlns="http://www.w3.org/2000/svg"
                      width="12"
                      height="12"
                      viewBox="0 0 24 24"
                      fill="currentColor"
                      className="block"
                    >
                      <path d="M14 19h4V5h-4v14zm-8 0h4V5H6v14z" />
                    </svg>
                  ) : (
                    <svg
                      xmlns="http://www.w3.org/2000/svg"
                      width="12"
                      height="12"
                      viewBox="0 0 24 24"
                      fill="currentColor"
                      className="block"
                    >
                      <path d="M8 5v14l11-7z" />
                    </svg>
                  )}
                </button>
              )}
              <button
                onMouseDown={(e) => e.stopPropagation()}
                onClick={onClose}
                className="text-gray-400 hover:text-white cursor-pointer p-1 rounded-full"
                title="Hide Indicator"
              >
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  width="12"
                  height="12"
                  viewBox="0 0 24 24"
                  fill="currentColor"
                  className="block"
                >
                  <path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z" />
                </svg>
              </button>
            </div>
          </div>
          {currentTabState.status === 'error' && currentTabState.error && (
            <p className="text-xs text-red-400 px-2 pb-2 -mt-1">
              {currentTabState.error}
            </p>
          )}

          {/* Expanded History View */}
          {isExpanded && (
            <div
              className="p-2 border-t border-white/10"
              onMouseDown={(e) => e.stopPropagation()}
            >
              {historyTabs.length > 0 ? (
                <>
                  <div className="flex justify-between items-baseline px-2 pb-2">
                    <h3 className="text-sm font-bold">Run History</h3>
                    <p className="text-xs text-gray-400">
                      Avg: {formatElapsedTime(avgDuration)}
                    </p>
                  </div>
                  <div
                    ref={historyContainerRef}
                    className="overflow-y-auto pr-1"
                    style={{ height: `${historyHeight}px` }}
                  >
                    {historyTabs.map((tabState) => (
                      <TabHistory
                        key={tabState.tabId}
                        tabState={tabState}
                        onNavigate={onNavigate}
                      />
                    ))}
                  </div>
                  <div
                    onMouseDown={handleResizeMouseDown}
                    className="w-full h-2 cursor-s-resize mt-1 rounded"
                  ></div>
                </>
              ) : (
                <p className="text-xs text-gray-400 text-center py-2">
                  No completed runs in this session.
                </p>
              )}
            </div>
          )}
        </div>
      );
    }

    export default Indicator;
approved: true
