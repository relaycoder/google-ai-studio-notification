uuid: 139e8020-569d-4e94-8ec5-1b4e58b88fef
projectId: google-ai-studio-notification
createdAt: '2025-08-04T04:19:38.399Z'
linesAdded: 356
linesRemoved: 124
gitCommitMsg: 'feat: add draggable floating status indicator with React'
promptSummary: >-
  The user wants to add a draggable floating status indicator to the Chrome
  extension. I have implemented this by refactoring the project to use Vite,
  React, and Tailwind CSS. This includes adding new configuration files,
  updating dependencies, and replacing the original content script with a React
  application.
reasoning:
  - >-
    This is a great feature request! Adding a draggable floating indicator will
    definitely improve the user experience. To achieve this, I'll integrate
    React, Tailwind CSS, and Vite into your project. This involves a significant
    refactor of your project's structure and build process, but it will set you
    up with a modern and powerful development environment.
  - 'Here''s my plan:'
  - >-
    1.  **Project Setup**: I'll introduce Vite as the new build tool, along with
    React and Tailwind CSS. This requires new configuration files
    (`vite.config.ts`, `tailwind.config.js`, `postcss.config.js`) and updating
    `package.json` with the new dependencies and build scripts.
  - '2.  **Directory Restructure**:'
  - >-
    *   I'll create a new `public` directory for static assets like
    `manifest.json` and your icons/sounds, which Vite will automatically handle.
  - >-
    *   The content script logic will be moved into a new `src/content`
    directory, structured as a small React application.
  - >-
    3.  **Content Script Refactor**: I'll convert your existing `content.ts`
    into a React application.
  - >-
    *   The core state-checking logic will be moved into a main `App.tsx`
    component.
  - >-
    *   A new `Indicator.tsx` component will render the floating UI, showing the
    current status (`monitoring`, `running`, `stopped`, `error`).
  - '*   I''ll add a custom hook `useDrag.ts` to make the indicator draggable.'
  - >-
    4.  **Configuration Updates**: I'll update `tsconfig.json` and
    `.eslintrc.cjs` to support React and JSX syntax.
  - Let's get started.
  - '### Step 1: Deleting Old Files'
  - I'll start by removing the files that are being replaced or moved.
  - '### Step 2: Updating Build and Project Configuration'
  - >-
    Next, I'll update your `package.json` to include the new dependencies and
    scripts for Vite, React, and Tailwind. I'll also update your ESLint and
    TypeScript configurations.
  - '### Step 3: Adding New Configuration Files'
  - Here are the new configuration files for Vite, Tailwind, and PostCSS.
  - '### Step 4: Creating the `public` Directory and `manifest.json`'
  - >-
    I'll create the new `manifest.json` in a `public` directory. Vite will copy
    everything from `public` into the `dist` folder during the build.
  - >-
    **Important:** You will need to create a `public/assets` directory and place
    your `notification.mp3`, `icon48.png`, and `icon128.png` files inside it.
  - '### Step 5: Building the React-based Content Script'
  - >-
    Finally, here are the new files for the React application that will serve as
    your content script.
  - >-
    You're all set! After running `npm install` to get the new packages, you can
    use `npm run build` to build the extension or `npm run watch` to
    automatically rebuild on file changes. The final output will be in the
    `dist` directory, ready to be loaded into Chrome.
operations:
  - type: delete
    path: src/content.ts
  - type: delete
    path: src/manifest.json
  - type: write
    path: package.json
    content: |-
      {
        "name": "ai-studio-notifier",
        "version": "1.3.0",
        "description": "Plays a sound and shows a notification when a process in Google AI Studio finishes.",
        "private": true,
        "type": "module",
        "scripts": {
          "watch": "vite build --watch",
          "build": "vite build",
          "lint": "eslint \"src/**/*.{ts,tsx}\"",
          "format": "prettier --write \"src/**/*.{ts,tsx,json}\""
        },
        "dependencies": {
          "react": "^18.2.0",
          "react-dom": "^18.2.0"
        },
        "devDependencies": {
          "@types/chrome": "^0.0.251",
          "@types/react": "^18.2.45",
          "@types/react-dom": "^18.2.18",
          "@typescript-eslint/eslint-plugin": "^6.13.1",
          "@typescript-eslint/parser": "^6.13.1",
          "@vitejs/plugin-react": "^4.2.1",
          "autoprefixer": "^10.4.16",
          "eslint": "^8.55.0",
          "eslint-config-prettier": "^9.1.0",
          "eslint-plugin-prettier": "^5.0.1",
          "eslint-plugin-react": "^7.33.2",
          "eslint-plugin-react-hooks": "^4.6.0",
          "postcss": "^8.4.32",
          "prettier": "^3.1.0",
          "tailwindcss": "^3.4.0",
          "typescript": "^5.3.2",
          "vite": "^5.0.10"
        }
      }
    patchStrategy: replace
  - type: write
    path: .eslintrc.cjs
    content: |-
      --- .eslintrc.cjs
      +++ .eslintrc.cjs
      @@ -1,13 +1,25 @@
       module.exports = {
         parser: '@typescript-eslint/parser',
         extends: [
           'eslint:recommended',
           'plugin:@typescript-eslint/recommended',
      +    'plugin:react/recommended',
      +    'plugin:react-hooks/recommended',
           'plugin:prettier/recommended',
         ],
         parserOptions: {
           ecmaVersion: 2020,
           sourceType: 'module',
      +    ecmaFeatures: {
      +      jsx: true,
      +    },
      +  },
      +  settings: {
      +    react: {
      +      version: 'detect',
      +    },
         },
         env: {
           browser: true,
      @@ -15,5 +27,6 @@
         },
         rules: {
           // Add any custom rules here
      +    'react/react-in-jsx-scope': 'off',
         },
       };
    patchStrategy: new-unified
  - type: write
    path: tsconfig.json
    content: |-
      <<<<<<< SEARCH
          "typeRoots": [
            "./node_modules/@types"
          ]
        },
        "include": [
          "src/**/*.ts"
        ],
      =======
          "typeRoots": [
            "./node_modules/@types"
          ],
          "jsx": "react-jsx"
        },
        "include": [
          "src/**/*.ts",
          "src/**/*.tsx",
          "vite.config.ts"
        ],
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: vite.config.ts
    content: |-
      import { defineConfig } from 'vite';
      import react from '@vitejs/plugin-react';
      import { resolve } from 'path';

      // https://vitejs.dev/config/
      export default defineConfig({
        plugins: [react()],
        publicDir: 'public',
        build: {
          outDir: 'dist',
          sourcemap: 'inline', // Recommended for debugging extensions
          rollupOptions: {
            input: {
              background: resolve(__dirname, 'src/background.ts'),
              content: resolve(__dirname, 'src/content/index.tsx'),
            },
            output: {
              entryFileNames: '[name].js',
              chunkFileNames: 'assets/[name].js',
              assetFileNames: (assetInfo) => {
                // Rename the output css file for the content script
                if (assetInfo.name === 'style.css') {
                  return 'content.css';
                }
                return 'assets/[name].[ext]';
              },
            },
          },
        },
      });
    patchStrategy: replace
  - type: write
    path: tailwind.config.js
    content: |-
      /** @type {import('tailwindcss').Config} */
      export default {
        content: ['./src/**/*.{js,ts,jsx,tsx}'],
        theme: {
          extend: {},
        },
        plugins: [],
      };
    patchStrategy: replace
  - type: write
    path: postcss.config.js
    content: |-
      export default {
        plugins: {
          tailwindcss: {},
          autoprefixer: {},
        },
      };
    patchStrategy: replace
  - type: write
    path: public/manifest.json
    content: |-
      {
        "manifest_version": 3,
        "name": "AI Studio Notifier",
        "version": "1.3.0",
        "description": "Plays a sound and shows a notification when a process in Google AI Studio finishes.",
        "permissions": [
          "notifications",
          "tabs",
          "alarms",
          "storage"
        ],
        "host_permissions": [
          "https://aistudio.google.com/*"
        ],
        "background": {
          "service_worker": "background.js"
        },
        "content_scripts": [
          {
            "matches": ["https://aistudio.google.com/*"],
            "js": ["content.js"],
            "css": ["content.css"]
          }
        ],
        "web_accessible_resources": [
          {
            "resources": ["assets/*"],
            "matches": ["https://aistudio.google.com/*"]
          }
        ],
        "icons": {
          "48": "assets/icon48.png",
          "128": "assets/icon128.png"
        }
      }
    patchStrategy: replace
  - type: write
    path: src/content/style.css
    content: |-
      @tailwind base;
      @tailwind components;
      @tailwind utilities;
    patchStrategy: replace
  - type: write
    path: src/content/index.tsx
    content: |-
      import React from 'react';
      import ReactDOM from 'react-dom/client';
      import App from './App';
      import './style.css';

      // Create a root element to mount the React app
      const rootEl = document.createElement('div');
      rootEl.id = 'ai-studio-notifier-root';
      document.body.appendChild(rootEl);

      // Render the App component
      const root = ReactDOM.createRoot(rootEl);
      root.render(
        <React.StrictMode>
          <App />
        </React.StrictMode>
      );
    patchStrategy: replace
  - type: write
    path: src/content/App.tsx
    content: |-
      import { useState, useEffect, useCallback } from 'react';
      import Indicator from './Indicator';

      export type Status = 'monitoring' | 'running' | 'stopped' | 'error';

      function App() {
        const [status, setStatus] = useState<Status>('monitoring');
        const [error, setError] = useState<string | null>(null);

        const checkState = useCallback(() => {
          try {
            const stopButtonExists = !!document.querySelector<SVGRectElement>(
              'rect[class*="stoppable-stop"]'
            );

            setStatus((prevStatus) => {
              const wasRunning = prevStatus === 'running';
              if (wasRunning && !stopButtonExists) {
                // State transition: running -> stopped
                console.log(
                  'AI Studio process finished. Playing sound and sending desktop notification.'
                );
                chrome.runtime.sendMessage({ type: 'processFinished' });
                return 'stopped';
              }

              const newStatus = stopButtonExists ? 'running' : 'monitoring';
              if (
                prevStatus !== newStatus &&
                !(prevStatus === 'stopped' && newStatus === 'monitoring')
              ) {
                console.log(
                  `AI Studio Notifier: State changed to ${
                    stopButtonExists ? 'Running' : 'Monitoring'
                  }`
                );
              }
              // If we were stopped, and a new process hasn't started, stay stopped visually
              // until a new run starts.
              if (prevStatus === 'stopped' && !stopButtonExists) {
                  return 'stopped';
              }

              return newStatus;
            });
            setError(null);
          } catch (e) {
            console.error('AI Studio Notifier: Error during state check.', e);
            setError('An error occurred during check.');
            setStatus('error');
          }
        }, []);

        useEffect(() => {
          // Initial Check after a short delay
          const timeoutId = setTimeout(checkState, 2000);

          // Observer Setup
          const observer = new MutationObserver(checkState);
          observer.observe(document.body, {
            childList: true,
            subtree: true,
          });
          console.log(
            'AI Studio Notifier: MutationObserver is now watching the page.'
          );

          return () => {
            clearTimeout(timeoutId);
            observer.disconnect();
          };
        }, [checkState]);

        return <Indicator status={status} error={error} />;
      }

      export default App;
    patchStrategy: replace
  - type: write
    path: src/content/useDrag.ts
    content: |-
      import { useState, useCallback, RefObject } from 'react';

      interface Position {
        x: number;
        y: number;
      }

      export function useDrag(ref: RefObject<HTMLElement>) {
        const [position, setPosition] = useState<Position>({
          x: window.innerWidth - 250, // Initial position top-right
          y: 20,
        });

        const handleMouseDown = useCallback(
          (e: React.MouseEvent<HTMLDivElement>) => {
            // Prevents text selection while dragging
            e.preventDefault();

            const startPos = { x: e.clientX, y: e.clientY };
            const element = ref.current;
            if (!element) return;

            const handleMouseMove = (moveEvent: MouseEvent) => {
              const dx = moveEvent.clientX - startPos.x;
              const dy = moveEvent.clientY - startPos.y;
              setPosition({
                x: position.x + dx,
                y: position.y + dy,
              });
            };

            const handleMouseUp = () => {
              document.removeEventListener('mousemove', handleMouseMove);
              document.removeEventListener('mouseup', handleMouseUp);
            };

            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
          },
          [position.x, position.y, ref]
        );

        return {
          position,
          setPosition, // Expose setPosition for potential programmatic updates
          handleMouseDown,
        };
      }
    patchStrategy: replace
  - type: write
    path: src/content/Indicator.tsx
    content: >-
      import { useRef, useEffect, useState } from 'react';

      import { useDrag } from './useDrag';

      import type { Status } from './App';


      interface IndicatorProps {
        status: Status;
        error: string | null;
      }


      const statusConfig: Record<Status, { bgColor: string; text: string;
      animate: boolean }> = {
        monitoring: {
          bgColor: 'bg-blue-500',
          text: 'Monitoring',
          animate: false,
        },
        running: {
          bgColor: 'bg-green-500',
          text: 'Process Running',
          animate: true,
        },
        stopped: {
          bgColor: 'bg-yellow-500',
          text: 'Process Finished!',
          animate: false,
        },
        error: {
          bgColor: 'bg-red-500',
          text: 'Error!',
          animate: false,
        },
      };


      function Indicator({ status, error }: IndicatorProps) {
        const indicatorRef = useRef<HTMLDivElement>(null);
        const { position, handleMouseDown } = useDrag(indicatorRef);
        const [isVisible, setIsVisible] = useState(true);
        const audioRef = useRef<HTMLAudioElement | null>(null);

        useEffect(() => {
          // Preload audio element when component mounts
          const soundUrl = chrome.runtime.getURL('assets/notification.mp3');
          audioRef.current = new Audio(soundUrl);
        }, []);

        useEffect(() => {
          if (status === 'stopped') {
            audioRef.current
              ?.play()
              .catch((err) => console.error('Audio play failed: ', err));
          }
        }, [status]);

        if (!isVisible) {
          return null;
        }

        const config = statusConfig[status];

        return (
          <div
            ref={indicatorRef}
            className="fixed top-0 left-0 z-[99999] rounded-lg shadow-lg text-white font-sans select-none"
            style={{
              transform: `translate3d(${position.x}px, ${position.y}px, 0)`,
              backgroundColor: 'rgba(20, 20, 20, 0.8)',
              backdropFilter: 'blur(4px)',
            }}
          >
            <div
              className="flex items-center gap-3 p-2 cursor-grab"
              onMouseDown={handleMouseDown}
            >
              <div className="flex items-center gap-2">
                <span
                  className={`w-3 h-3 rounded-full ${config.bgColor} ${
                    config.animate ? 'animate-pulse' : ''
                  }`}
                ></span>
                <span className="text-sm font-medium">{config.text}</span>
              </div>
              <button
                onClick={() => setIsVisible(false)}
                className="text-xs text-gray-400 hover:text-white cursor-pointer"
                title="Hide Indicator"
              >
                &#x2715;
              </button>
            </div>
            {status === 'error' && error && (
              <p className="text-xs text-red-400 px-2 pb-2 -mt-1">{error}</p>
            )}
          </div>
        );
      }


      export default Indicator;
    patchStrategy: replace
snapshot:
  vite.config.ts: null
  tailwind.config.js: null
  postcss.config.js: null
  public/manifest.json: null
  src/content/style.css: null
  src/content/index.tsx: null
  src/content/App.tsx: null
  src/content/useDrag.ts: null
  src/content/Indicator.tsx: null
  src/content.ts: |
    let isRunning = false;

    function init() {
      console.log('AI Studio Notifier initializing...');
      // --- Sound Setup ---
      // Note: You must add a 'notification.mp3' file to the extension's root directory.
      const soundUrl = chrome.runtime.getURL('assets/notification.mp3');
      const audio = new Audio(soundUrl);

      function playSound() {
        audio
          .play()
          .catch((error) =>
            console.error(
              'Audio play failed. Make sure notification.mp3 exists and is valid.',
              error
            )
          );
      }

      // --- State Checking Logic ---
      function checkForStopButton() {
        // The user identified an element with class "stoppable-stop" as the indicator.
        // This selector looks for a <rect> element whose class list contains "stoppable-stop".
        // Using [class*="..."] makes it robust against other dynamic classes added by the framework.
        return document.querySelector<SVGRectElement>(
          'rect[class*="stoppable-stop"]'
        );
      }

      function checkState() {
        const stopButtonExists = !!checkForStopButton();

        if (isRunning && !stopButtonExists) {
          // This is the transition we're looking for:
          // State 1 (running, button exists) to State 2 (stopped, button absent).
          console.log(
            'AI Studio process finished. Playing sound and sending desktop notification.'
          );
          playSound();
          // Send a message to the background script to show a desktop notification
          chrome.runtime.sendMessage({ type: 'processFinished' });
        }

        // Update the current state for the next check.
        if (isRunning !== stopButtonExists) {
          console.log(
            `AI Studio Notifier: State changed to ${stopButtonExists ? 'Running' : 'Stopped'
            }`
          );
          isRunning = stopButtonExists;
        }
      }

      // --- Observer Setup ---
      const observer = new MutationObserver(() => {
        // A DOM change occurred, let's re-evaluate the state.
        checkState();
      });

      // We start observing the entire body for changes in its descendants.
      observer.observe(document.body, {
        childList: true,
        subtree: true,
      });
      console.log(
        'AI Studio Notifier: MutationObserver is now watching the page for changes.'
      );

      // --- Initial Check ---
      // A short delay helps ensure the page's dynamic content has loaded.
      setTimeout(checkState, 2000);
    }

    // The script might be injected before the body is fully available.
    if (document.body) {
      init();
    } else {
      // If not, wait for it.
      window.addEventListener('DOMContentLoaded', init);
    }
  src/manifest.json: |-
    {
      "manifest_version": 3,
      "name": "AI Studio Notifier",
      "version": "1.2.0",
      "description": "Plays a sound and shows a notification when a process in Google AI Studio finishes.",
      "permissions": [
        "notifications",
        "tabs",
        "alarms",
        "storage"
      ],
      "host_permissions": [
        "https://aistudio.google.com/*"
      ],
      "background": {
        "service_worker": "background.js"
      },
      "content_scripts": [
        {
          "matches": ["https://aistudio.google.com/*"],
          "js": ["content.js"]
        }
      ],
      "web_accessible_resources": [
        {
          "resources": ["assets/*"],
          "matches": ["https://aistudio.google.com/*"]
        }
      ],
      "icons": {
        "48": "assets/icon48.png",
        "128": "assets/icon128.png"
      }
    }
  package.json: |-
    {
      "name": "ai-studio-notifier",
      "version": "1.2.0",
      "description": "Plays a sound and shows a notification when a process in Google AI Studio finishes.",
      "private": true,
      "scripts": {
        "build": "tsc && npm run copy-assets",
        "copy-assets": "cp src/manifest.json dist/ && cp -r public/. dist/assets",
        "lint": "eslint \"src/**/*.ts\"",
        "format": "prettier --write \"src/**/*.{ts,json}\""
      },
      "devDependencies": {
        "@types/chrome": "^0.0.251",
        "@typescript-eslint/eslint-plugin": "^6.13.1",
        "@typescript-eslint/parser": "^6.13.1",
        "eslint": "^8.55.0",
        "eslint-config-prettier": "^9.1.0",
        "eslint-plugin-prettier": "^5.0.1",
        "prettier": "^3.1.0",
        "typescript": "^5.3.2"
      }
    }
  .eslintrc.cjs: |-
    module.exports = {
      parser: '@typescript-eslint/parser',
      extends: [
        'eslint:recommended',
        'plugin:@typescript-eslint/recommended',
        'plugin:prettier/recommended',
      ],
      parserOptions: {
        ecmaVersion: 2020,
        sourceType: 'module',
      },
      env: {
        browser: true,
        es6: true,
      },
      rules: {
        // Add any custom rules here
      },
    };
  tsconfig.json: |-
    {
      "compilerOptions": {
        "target": "es2020",
        "module": "es2020",
        "strict": true,
        "outDir": "./dist",
        "rootDir": "./src",
        "esModuleInterop": true,
        "forceConsistentCasingInFileNames": true,
        "typeRoots": [
          "./node_modules/@types"
        ]
      },
      "include": [
        "src/**/*.ts"
      ],
      "exclude": [
        "node_modules"
      ]
    }
approved: true
