uuid: c257790b-dafd-45a8-98e3-b1d75c2e9124
projectId: google-ai-studio-notification
createdAt: '2025-08-05T14:08:17.900Z'
linesAdded: 79
linesRemoved: 30
gitCommitMsg: 'feat: make indicator resizable and improve UX'
promptSummary: >-
  The user wants to fix several issues and add a feature: 1. A `window is not
  defined` error in the background script. 2. Clicking the entire indicator
  header should expand/collapse the history. 3. Clicks on history items were not
  working. 4. The expanded indicator should be resizable.
reasoning:
  - >-
    Hello! As an expert AI programmer, I've analyzed your request and will now
    apply the necessary changes to your project. Here are the modifications to
    address the issues you've encountered and implement the new features.
  - '### Step-by-step Reasoning'
  - >-
    1.  **`background.ts`:** I've corrected a `ReferenceError` in the service
    worker. The `window` object is not available in this context, so I've
    changed `window.setInterval` to the global `setInterval`. This resolves the
    error you were seeing on extension startup.
  - >-
    2.  **`src/content/useDrag.ts`:** I've enhanced the `useDrag` hook to
    distinguish between a "drag" action and a "click" action. This is crucial
    for the next step. The hook now accepts an `onClickWithoutDrag` callback,
    which is fired if the mouse is pressed and released without significant
    movement. I've also restricted dragging to the left mouse button.
  - >-
    3.  **`src/content/Indicator.tsx`:** This file has the most significant
    changes to address your points:
  - >-
    *   **Clickable Header to Expand/Collapse:** The main header of the
    indicator is now clickable to toggle the history view. This is achieved by
    passing a toggle function to our updated `useDrag` hook. I've removed the
    small chevron button for expanding, as the entire header now serves this
    purpose, providing a larger click target.
  - >-
    *   **Button Click Fix:** I've added `onMouseDown={(e) =>
    e.stopPropagation()}` to the buttons in the header (Pause/Resume, Close).
    This prevents a click on a button from being misinterpreted as an attempt to
    drag or expand the indicator.
  - >-
    *   **Resizable History View:** The expanded history view is now resizable.
    I've added a resize handle at the bottom. You can drag it to adjust the
    height of the history list. This height is saved and restored across
    sessions.
  - >-
    *   **History Item Click Fix:** To ensure clicks on history items (to
    navigate to a tab) are always registered, I've added `onMouseDown={(e) =>
    e.stopPropagation()}` to the history container. This prevents any accidental
    mouse-down events from being captured by the drag handler on the main
    component.
  - >-
    These changes should resolve the errors, improve the user experience of the
    indicator, and add the requested resize functionality.
  - '### Code Modifications'
  - Here are the code patches for the files.
operations:
  - type: write
    path: src/background.ts
    content: |-
      <<<<<<< SEARCH
      function ensureTimerIsRunning() {
        if (!timerInterval) {
          timerInterval = window.setInterval(updateTimers, 1000);
        }
      }
      =======
      function ensureTimerIsRunning() {
        if (!timerInterval) {
          timerInterval = setInterval(updateTimers, 1000);
        }
      }
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: src/content/useDrag.ts
    content: >-
      --- src/content/useDrag.ts

      +++ src/content/useDrag.ts

      @@ -8,7 +8,10 @@
         y: number;
       }
       
      -export function useDrag(ref: RefObject<HTMLElement>) {

      +export function useDrag(

      +  ref: RefObject<HTMLElement>,

      +  onClickWithoutDrag?: () => void

      +) {
         const [position, setPosition] = useState<Position>({
           x: window.innerWidth - 250, // Initial position top-right
           y: 20,
      @@ -32,32 +35,42 @@
         const handleMouseDown = useCallback(
           (e: React.MouseEvent<HTMLDivElement>) => {
             // Prevents text selection while dragging
             e.preventDefault();
      +      // Only start drag for left mouse button

      +      if (e.button !== 0) return;
       
             const startPos = { x: e.clientX, y: e.clientY };
             const elementStartPos = positionRef.current; // Use ref to get position at drag start
             const element = ref.current;
             if (!element) return;
      +      let didDrag = false;
       
             const handleMouseMove = (moveEvent: MouseEvent) => {
      +        didDrag = true; // Any move is a drag
               const dx = moveEvent.clientX - startPos.x;
               const dy = moveEvent.clientY - startPos.y;
               setPosition({
                 x: elementStartPos.x + dx,
                 y: elementStartPos.y + dy,
               });
             };
       
             const handleMouseUp = () => {
               document.removeEventListener('mousemove', handleMouseMove);
               document.removeEventListener('mouseup', handleMouseUp);
      -        // On mouse up, the drag is over. The `position` state has been
      updated

      -        // by the last `handleMouseMove`. The `useEffect` listening to
      `position`

      -        // will have updated `positionRef.current`. We can now save it.

      -        chrome.storage.local.set({ [STORAGE_KEY]: positionRef.current });

      +        if (didDrag) {

      +          // On mouse up, the drag is over. The `position` state has been
      updated

      +          // by the last `handleMouseMove`. The `useEffect` listening to
      `position`

      +          // will have updated `positionRef.current`. We can now save it.

      +          chrome.storage.local.set({ [STORAGE_KEY]: positionRef.current
      });

      +        } else if (onClickWithoutDrag) {

      +          onClickWithoutDrag();

      +        }
             };
       
             document.addEventListener('mousemove', handleMouseMove);
             document.addEventListener('mouseup', handleMouseUp);
           },
      -    [ref] // No dependency on `position` state

      +    [ref, onClickWithoutDrag]
         );
       
         return {
    patchStrategy: new-unified
  - type: write
    path: src/content/Indicator.tsx
    content: >-
      --- src/content/Indicator.tsx

      +++ src/content/Indicator.tsx

      @@ -1,4 +1,4 @@

      -import { useRef, useEffect, useState } from 'react';

      +import { useRef, useEffect, useState, useCallback } from 'react';
       import { useDrag } from './useDrag';
       import { statusConfig } from './constants';
       import type { IndicatorProps, RunHistoryEntry, TabState } from '../types';
      @@ -87,11 +87,26 @@
         onNavigate,
       }: IndicatorProps) {
         const indicatorRef = useRef<HTMLDivElement>(null);
      -  const { position, handleMouseDown } = useDrag(indicatorRef);

      +  const historyContainerRef = useRef<HTMLDivElement>(null);
         const [isExpanded, setIsExpanded] = useState(false);
      +  const [historyHeight, setHistoryHeight] = useState(240); // default is
      max-h-60 (240px)

      +  const INDICATOR_HEIGHT_KEY = 'indicator-history-height';

      +

      +  const handleToggleExpand = useCallback(() => {

      +    // Only allow expanding if there is history to show

      +    if (Object.values(allTabsState).some((tab) => tab.history.length >
      0)) {

      +      setIsExpanded((expanded) => !expanded);

      +    }

      +  }, [allTabsState]);

      +

      +  const { position, handleMouseDown } = useDrag(indicatorRef,
      handleToggleExpand);
         const audioRef = useRef<HTMLAudioElement | null>(null);
       
         useEffect(() => {
      +    chrome.storage.local.get(INDICATOR_HEIGHT_KEY, (result) => {

      +      if (result[INDICATOR_HEIGHT_KEY]) {

      +        setHistoryHeight(result[INDICATOR_HEIGHT_KEY]);

      +      }

      +    });
           // Preload audio element when component mounts
           const soundUrl = chrome.runtime.getURL('notification.mp3');
           audioRef.current = new Audio(soundUrl);
      @@ -104,6 +119,32 @@
           }
         }, [currentTabState?.status]);
       
      +  const handleResizeMouseDown = useCallback(

      +    (e: React.MouseEvent<HTMLDivElement>) => {

      +      e.preventDefault();

      +      e.stopPropagation(); // Prevent drag-to-move and expand/collapse

      +

      +      const startY = e.clientY;

      +      const startHeight = historyContainerRef.current?.clientHeight ??
      240;

      +

      +      const handleMouseMove = (moveEvent: MouseEvent) => {

      +        const dy = moveEvent.clientY - startY;

      +        const newHeight = Math.max(50, startHeight + dy); // min height
      50px

      +        setHistoryHeight(newHeight);

      +      };

      +

      +      const handleMouseUp = (upEvent: MouseEvent) => {

      +        document.removeEventListener('mousemove', handleMouseMove);

      +        document.removeEventListener('mouseup', handleMouseUp);

      +        const dy = upEvent.clientY - startY;

      +        const newHeight = Math.max(50, startHeight + dy);

      +        chrome.storage.local.set({ [INDICATOR_HEIGHT_KEY]: newHeight });

      +      };

      +

      +      document.addEventListener('mousemove', handleMouseMove);

      +      document.addEventListener('mouseup', handleMouseUp);

      +    },

      +    [] // No dependencies needed, we get startHeight from ref

      +  );

      +
         if (!currentTabState) {
           return null;
         }
      @@ -165,6 +206,7 @@
               <div className="flex items-center flex-shrink-0">
                 {isPausable && (
                   <button
      +              onMouseDown={(e) => e.stopPropagation()}
                     onClick={onPauseResume}
                     className="text-gray-400 hover:text-white cursor-pointer p-1 rounded-full"
                     title={currentTabState.status === 'paused' ? 'Resume' : 'Pause'}
      @@ -194,30 +236,9 @@
                     )}
                   </button>
                 )}
      -          {historyTabs.length > 0 && (

      -            <button

      -              onClick={() => setIsExpanded(!isExpanded)}

      -              className="text-gray-400 hover:text-white cursor-pointer
      p-1 rounded-full"

      -              title={isExpanded ? 'Collapse History' : 'Expand History'}

      -            >

      -              <svg

      -                xmlns="http://www.w3.org/2000/svg"

      -                width="12"

      -                height="12"

      -                viewBox="0 0 24 24"

      -                fill="currentColor"

      -                className="block transition-transform"

      -                style={{ transform: isExpanded ? 'rotate(180deg)' :
      'none' }}

      -              >

      -                <path d="M7.41 8.59 12 13.17l4.59-4.58L18 10l-6 6-6-6z"
      />

      -              </svg>

      -            </button>

      -          )}
                 <button
      +            onMouseDown={(e) => e.stopPropagation()}
                   onClick={onClose}
                   className="text-gray-400 hover:text-white cursor-pointer p-1 rounded-full"
                   title="Hide Indicator"
      @@ -242,7 +263,10 @@
       
             {/* Expanded History View */}
             {isExpanded && (
      -        <div className="p-2 border-t border-white/10">

      +        <div

      +          className="p-2 border-t border-white/10"

      +          onMouseDown={(e) => e.stopPropagation()}

      +        >
                 {historyTabs.length > 0 ? (
                   <>
                     <div className="flex justify-between items-baseline px-2 pb-2">
      @@ -251,7 +275,11 @@
                         Avg: {formatElapsedTime(avgDuration)}
                       </p>
                     </div>
      -              <div className="max-h-60 overflow-y-auto pr-1">

      +              <div

      +                ref={historyContainerRef}

      +                className="overflow-y-auto pr-1"

      +                style={{ height: `${historyHeight}px` }}

      +              >
                       {historyTabs.map((tabState) => (
                         <TabHistory
                           key={tabState.tabId}
      @@ -260,6 +288,10 @@
                         />
                       ))}
                     </div>
      +              <div

      +                onMouseDown={handleResizeMouseDown}

      +                className="w-full h-2 cursor-s-resize mt-1 rounded"

      +              ></div>
                   </>
                 ) : (
                   <p className="text-xs text-gray-400 text-center py-2">
    patchStrategy: new-unified
snapshot:
  src/background.ts: |-
    import type {
      GlobalState,
      TabState,
      RunHistoryEntry,
      NotificationContext,
      Message,
    } from './types';

    // --- State Management ---

    const STATE_KEY = 'ai-studio-tracker-state';
    let state: GlobalState = {};
    let timerInterval: number | undefined;
    let ports: { [tabId: number]: chrome.runtime.Port } = {};

    async function getState(): Promise<GlobalState> {
      const result = await chrome.storage.local.get(STATE_KEY);
      return result[STATE_KEY] || {};
    }

    async function setState(newState: GlobalState): Promise<void> {
      state = newState;
      await chrome.storage.local.set({ [STATE_KEY]: newState });
      broadcastState();
    }

    function broadcastState() {
      for (const tabIdStr in ports) {
        const port = ports[tabIdStr];
        try {
          port.postMessage({ type: 'stateUpdate', state: state });
        } catch (e) {
          console.warn(`Could not send state to tab ${tabIdStr}, port is likely closed.`);
        }
      }
    }

    function getInitialTabState(tabId: number, windowId: number): TabState {
      return {
        tabId,
        windowId,
        status: 'monitoring',
        runName: null,
        startTime: null,
        elapsedTime: 0,
        pausedTime: 0,
        pauseStartTime: null,
        history: [],
        error: null,
        isVisible: true,
      };
    }

    // --- Timer for Elapsed Time ---

    function updateTimers() {
      let needsUpdate = false;
      const now = Date.now();

      for (const tabIdStr in state) {
        const tabId = parseInt(tabIdStr, 10);
        const tab = state[tabId];
        if (tab.status === 'running' && tab.startTime) {
          tab.elapsedTime = now - tab.startTime - tab.pausedTime;
          needsUpdate = true;
        }
      }

      if (needsUpdate) {
        state = { ...state };
        broadcastState();
      }

      const anyRunning = Object.values(state).some(
        (t) => t.status === 'running'
      );
      if (!anyRunning && timerInterval) {
        clearInterval(timerInterval);
        timerInterval = undefined;
      }
    }

    function ensureTimerIsRunning() {
      if (!timerInterval) {
        timerInterval = window.setInterval(updateTimers, 1000);
      }
    }

    // --- Port-based Communication ---

    chrome.runtime.onConnect.addListener((port) => {
      if (port.name !== 'content-script' || !port.sender?.tab?.id) {
        return;
      }
      const tabId = port.sender.tab.id;
      const windowId = port.sender.tab.windowId ?? -1;
      ports[tabId] = port;

      port.onMessage.addListener(async (message: Message) => {
        switch (message.type) {
          case 'startRun':
            await handleStartRun(tabId, message.runName);
            break;
          case 'stopRun':
            await handleStopRun(tabId, message.isError, message.error);
            break;
          case 'pauseResume':
            await handlePauseResume(tabId);
            break;
          case 'closeIndicator':
            await handleCloseIndicator(tabId);
            break;
          case 'navigateToTab':
            handleNavigateToTab(message.tabId, message.windowId);
            break;
          case 'error':
            const currentState = await getState();
            const tab = currentState[tabId];
            if (tab) {
              tab.status = 'error';
              tab.error = message.error;
              await setState(currentState);
            }
            break;
        }
      });

      port.onDisconnect.addListener(() => {
        delete ports[tabId];
        console.log(`Port disconnected for tab ${tabId}`);
      });

      // Handle initial connection
      (async () => {
        let currentState = await getState();
        if (!currentState[tabId]) {
          currentState[tabId] = getInitialTabState(tabId, windowId);
        } else {
          currentState[tabId].isVisible = true; // Make visible on reconnect
          currentState[tabId].windowId = windowId;
        }
        await setState(currentState);
        currentState = await getState(); // Re-read state after setState
        port.postMessage({
          type: 'init',
          tabId: tabId,
          state: currentState,
        });
      })();
    });


    async function handleStartRun(tabId: number, runName: string | null) {
      const currentState = await getState();
      const tab = currentState[tabId];
      if (!tab) return;

      tab.status = 'running';
      tab.startTime = Date.now();
      tab.runName = runName;
      tab.elapsedTime = 0;
      tab.pausedTime = 0;
      tab.pauseStartTime = null;
      tab.error = null;

      await setState(currentState);
      ensureTimerIsRunning();
    }

    async function handleStopRun(
      tabId: number,
      isError = false,
      error?: string
    ) {
      const currentState = await getState();
      const tab = currentState[tabId];
      if (!tab || tab.status === 'monitoring' || tab.status === 'stopped') return;

      const endTime = Date.now();
      const finalElapsedTime = tab.startTime
        ? endTime - tab.startTime - tab.pausedTime
        : 0;

      const finalStatus = isError ? 'error' : 'stopped';

      const historyEntry: RunHistoryEntry = {
        id: `${tabId}-${endTime}`,
        runName: tab.runName,
        durationMs: finalElapsedTime,
        status: finalStatus,
        endTime: endTime,
      };
      tab.history.unshift(historyEntry);
      if (tab.history.length > 20) {
        tab.history.pop();
      }

      tab.status = 'stopped';
      tab.startTime = null;
      tab.runName = null;
      tab.elapsedTime = finalElapsedTime;
      tab.error = error || null;

      await setState(currentState);

      if (finalElapsedTime >= 3000) {
        console.log(
          `AI Studio process finished. Sending notification for run: "${historyEntry.runName}".`
        );
        createNotification({
          tabId: tab.tabId,
          windowId: tab.windowId,
          durationMs: finalElapsedTime,
          runName: historyEntry.runName,
        });
      }
    }

    async function handlePauseResume(tabId: number) {
      const currentState = await getState();
      const tab = currentState[tabId];
      if (!tab) return;

      if (tab.status === 'running') {
        tab.pauseStartTime = Date.now();
        tab.status = 'paused';
        // Update elapsed time one last time before pausing interval
        if (tab.startTime) {
            tab.elapsedTime = Date.now() - tab.startTime - tab.pausedTime;
        }

      } else if (tab.status === 'paused') {
        if (tab.pauseStartTime) {
          tab.pausedTime += Date.now() - tab.pauseStartTime;
        }
        tab.pauseStartTime = null;
        tab.status = 'running';
        ensureTimerIsRunning();
      }
      await setState(currentState);
    }

    async function handleCloseIndicator(tabId: number) {
      const currentState = await getState();
      const tab = currentState[tabId];
      if (tab) {
        tab.isVisible = false;
        await setState(currentState);
      }
    }

    function handleNavigateToTab(tabId: number, windowId: number) {
      chrome.windows.update(windowId, { focused: true });
      chrome.tabs.update(tabId, { active: true });
    }

    // --- Tab Lifecycle Management ---

    chrome.tabs.onRemoved.addListener(async (tabId) => {
      const currentState = await getState();
      if (currentState[tabId]) {
        delete currentState[tabId];
        await setState(currentState);
      }
    });


    // --- Notification Logic ---

    function formatDuration(ms: number | null | undefined): string {
      if (!ms || ms < 1000) {
        return '';
      }
      const totalSeconds = Math.round(ms / 1000);
      if (totalSeconds < 60) {
        return `${totalSeconds}s`;
      }
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = totalSeconds % 60;
      if (seconds === 0) {
        return `${minutes}m`;
      }
      return `${minutes}m ${seconds}s`;
    }

    function createNotification(context: NotificationContext) {
      const durationText = formatDuration(context.durationMs);
      const durationPart = durationText ? `in ${durationText}` : '';

      let title: string;
      if (context.runName) {
        title = ['Finished', durationPart, `- ${context.runName}`]
          .filter(Boolean)
          .join(' ');
      } else {
        title = ['AI Studio Process Finished', durationPart]
          .filter(Boolean)
          .join(' ');
      }

      const message = `Your process has finished running.`;
      chrome.notifications.create(
        {
          type: 'basic',
          iconUrl: 'icon128.png',
          title: title,
          message: message,
          priority: 2,
          requireInteraction: false,
          buttons: [{ title: 'Dismiss' }, { title: 'Remind in 5 min' }],
        },
        (notificationId) => {
          if (notificationId) {
            const storageKey = `notification:${notificationId}`;
            chrome.storage.local.set({ [storageKey]: context });
            console.log(
              `Notification created: ${notificationId}. Context stored.`
            );
          }
        }
      );
    }

    chrome.notifications.onClicked.addListener(async (notificationId) => {
      const storageKey = `notification:${notificationId}`;
      const data = await chrome.storage.local.get(storageKey);
      const context = data[storageKey] as NotificationContext | undefined;

      if (!context) {
        console.warn(`No context found for clicked notification: ${notificationId}`);
        return;
      }

      handleNavigateToTab(context.tabId, context.windowId);
      chrome.notifications.clear(notificationId);
    });

    chrome.notifications.onButtonClicked.addListener(
      async (notificationId, buttonIndex) => {
        const storageKey = `notification:${notificationId}`;
        const data = await chrome.storage.local.get(storageKey);
        const context = data[storageKey] as NotificationContext | undefined;

        if (!context) {
          console.warn(`No context found for notification: ${notificationId}`);
          return;
        }

        switch (buttonIndex) {
          case 0: // Dismiss
            chrome.notifications.clear(notificationId);
            break;
          case 1: // Remind in 5 min
            {
              const alarmName = `remind-${notificationId}`;
              await chrome.storage.local.set({ [alarmName]: context });
              chrome.alarms.create(alarmName, { delayInMinutes: 5 });
              chrome.notifications.clear(notificationId);
            }
            break;
        }
      }
    );

    // Listener for when a notification is closed (programmatically or by user)
    // This is crucial for cleaning up storage to prevent exceeding quotas.
    chrome.notifications.onClosed.addListener((notificationId) => {
      const storageKey = `notification:${notificationId}`;
      // We don't need to await this, it can run in the background.
      chrome.storage.local.remove(storageKey);
      console.log(
        `Cleaned up storage for closed notification: ${notificationId}`
      );
    });

    chrome.alarms.onAlarm.addListener(async (alarm) => {
      if (alarm.name.startsWith('remind-')) {
        const data = await chrome.storage.local.get(alarm.name);
        const context = data[alarm.name] as NotificationContext | undefined;

        if (context) {
          console.log(`Re-creating notification from alarm: ${alarm.name}`);
          createNotification(context);
          await chrome.storage.local.remove(alarm.name);
        }
      }
    });

    // --- Service Worker Startup ---
    (async () => {
      state = await getState();
      console.log('AI Studio Notifier: Background state loaded.');

      const tabs = await chrome.tabs.query({});
      const existingTabIds = new Set(tabs.map((t) => t.id).filter(Boolean));
      const stateTabIds = Object.keys(state).map(Number);
      let stateChanged = false;

      for (const tabId of stateTabIds) {
        if (!existingTabIds.has(tabId)) {
          delete state[tabId];
          stateChanged = true;
        }
      }

      if (stateChanged) {
        await setState(state);
      }

      if (Object.values(state).some((t) => t.status === 'running')) {
        ensureTimerIsRunning();
      }
    })();
  src/content/Indicator.tsx: |-
    import { useRef, useEffect, useState } from 'react';
    import { useDrag } from './useDrag';
    import { statusConfig } from './constants';
    import type { IndicatorProps, RunHistoryEntry, TabState } from '../types';

    function formatElapsedTime(ms: number): string {
      if (ms <= 0) return '00:00';
      const totalSeconds = Math.floor(ms / 1000);
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = totalSeconds % 60;
      const paddedMinutes = String(minutes).padStart(2, '0');
      const paddedSeconds = String(seconds).padStart(2, '0');
      return `${paddedMinutes}:${paddedSeconds}`;
    }

    function HistoryEntry({
      entry,
      onClick,
    }: {
      entry: RunHistoryEntry;
      onClick: () => void;
    }) {
      return (
        <div
          className="flex items-center justify-between text-xs px-2 py-1 hover:bg-white/10 rounded cursor-pointer"
          onClick={onClick}
        >
          <div className="flex items-center gap-2">
            <span
              className={
                entry.status === 'stopped' ? 'text-green-400' : 'text-red-400'
              }
            >
              {entry.status === 'stopped' ? '✔' : '✖'}
            </span>
            <span className="truncate max-w-[180px] text-gray-300">
              {entry.runName || 'Untitled Run'}
            </span>
          </div>
          <span className="font-mono text-gray-400">
            {formatElapsedTime(entry.durationMs)}
          </span>
        </div>
      );
    }

    function TabHistory({
      tabState,
      onNavigate,
    }: {
      tabState: TabState;
      onNavigate: (tabId: number, windowId: number) => void;
    }) {
      if (tabState.history.length === 0) return null;

      return (
        <div className="mt-2">
          <div
            className="text-xs font-bold text-gray-200 px-2 py-1 cursor-pointer hover:underline truncate"
            onClick={() => onNavigate(tabState.tabId, tabState.windowId)}
            title={tabState.history[0].runName || `Tab ${tabState.tabId}`}
          >
            Tab: {tabState.history[0].runName || `Tab ${tabState.tabId}`}
          </div>
          <div className="flex flex-col gap-0.5">
            {tabState.history.map((entry) => (
              <HistoryEntry
                key={entry.id}
                entry={entry}
                onClick={() => onNavigate(tabState.tabId, tabState.windowId)}
              />
            ))}
          </div>
        </div>
      );
    }

    function Indicator({
      currentTabState,
      allTabsState,
      onPauseResume,
      onClose,
      onNavigate,
    }: IndicatorProps) {
      const indicatorRef = useRef<HTMLDivElement>(null);
      const { position, handleMouseDown } = useDrag(indicatorRef);
      const [isExpanded, setIsExpanded] = useState(false);
      const audioRef = useRef<HTMLAudioElement | null>(null);

      useEffect(() => {
        // Preload audio element when component mounts
        const soundUrl = chrome.runtime.getURL('notification.mp3');
        audioRef.current = new Audio(soundUrl);
      }, []);

      useEffect(() => {
        if (currentTabState?.status === 'stopped') {
          audioRef.current
            ?.play()
            .catch((err) => console.error('Audio play failed: ', err));
        }
      }, [currentTabState?.status]);

      if (!currentTabState) {
        return null;
      }

      const config = statusConfig[currentTabState.status];
      const isPausable =
        currentTabState.status === 'running' ||
        currentTabState.status === 'paused' ||
        currentTabState.status === 'monitoring';

      const historyTabs = Object.values(allTabsState)
        .filter((tab) => tab.history.length > 0)
        .sort((a, b) => {
          const aLast = a.history[0]?.endTime ?? 0;
          const bLast = b.history[0]?.endTime ?? 0;
          return bLast - aLast;
        });

      const totalRuns = historyTabs.reduce(
        (sum, tab) => sum + tab.history.length,
        0
      );
      const totalDuration = historyTabs.reduce(
        (sum: number, tab: TabState) =>
          sum +
          tab.history.reduce(
            (tabSum: number, run: RunHistoryEntry) => tabSum + run.durationMs,
            0
          ),
        0
      );
      const avgDuration = totalRuns > 0 ? totalDuration / totalRuns : 0;

      return (
        <div
          ref={indicatorRef}
          className="fixed top-0 left-0 z-[99999] rounded-lg shadow-lg text-white font-sans select-none w-64"
          style={{
            transform: `translate3d(${position.x}px, ${position.y}px, 0)`,
            backgroundColor: 'rgba(20, 20, 20, 0.8)',
            backdropFilter: 'blur(4px)',
          }}
        >
          <div
            className="flex items-center gap-3 p-2 cursor-grab"
            onMouseDown={handleMouseDown}
          >
            <div className="flex items-center gap-2 flex-grow min-w-0">
              <span
                className={`w-3 h-3 rounded-full flex-shrink-0 ${config.bgColor} ${
                  config.animate ? 'animate-pulse' : ''
                }`}
              ></span>
              <span className="text-sm font-medium truncate">
                {currentTabState.runName
                  ? currentTabState.runName
                  : config.text}
              </span>
              {(currentTabState.status === 'running' ||
                currentTabState.status === 'paused' ||
                currentTabState.status === 'stopped') && (
                <span className="text-sm font-mono text-gray-300">
                  {formatElapsedTime(currentTabState.elapsedTime)}
                </span>
              )}
            </div>
            <div className="flex items-center flex-shrink-0">
              {isPausable && (
                <button
                  onClick={onPauseResume}
                  className="text-gray-400 hover:text-white cursor-pointer p-1 rounded-full"
                  title={currentTabState.status === 'paused' ? 'Resume' : 'Pause'}
                >
                  {currentTabState.status === 'running' ||
                  currentTabState.status === 'monitoring' ? (
                    <svg
                      xmlns="http://www.w3.org/2000/svg"
                      width="12"
                      height="12"
                      viewBox="0 0 24 24"
                      fill="currentColor"
                      className="block"
                    >
                      <path d="M14 19h4V5h-4v14zm-8 0h4V5H6v14z" />
                    </svg>
                  ) : (
                    <svg
                      xmlns="http://www.w3.org/2000/svg"
                      width="12"
                      height="12"
                      viewBox="0 0 24 24"
                      fill="currentColor"
                      className="block"
                    >
                      <path d="M8 5v14l11-7z" />
                    </svg>
                  )}
                </button>
              )}
              {historyTabs.length > 0 && (
                <button
                  onClick={() => setIsExpanded(!isExpanded)}
                  className="text-gray-400 hover:text-white cursor-pointer p-1 rounded-full"
                  title={isExpanded ? 'Collapse History' : 'Expand History'}
                >
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    width="12"
                    height="12"
                    viewBox="0 0 24 24"
                    fill="currentColor"
                    className="block transition-transform"
                    style={{ transform: isExpanded ? 'rotate(180deg)' : 'none' }}
                  >
                    <path d="M7.41 8.59 12 13.17l4.59-4.58L18 10l-6 6-6-6z" />
                  </svg>
                </button>
              )}
              <button
                onClick={onClose}
                className="text-gray-400 hover:text-white cursor-pointer p-1 rounded-full"
                title="Hide Indicator"
              >
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  width="12"
                  height="12"
                  viewBox="0 0 24 24"
                  fill="currentColor"
                  className="block"
                >
                  <path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z" />
                </svg>
              </button>
            </div>
          </div>
          {currentTabState.status === 'error' && currentTabState.error && (
            <p className="text-xs text-red-400 px-2 pb-2 -mt-1">
              {currentTabState.error}
            </p>
          )}

          {/* Expanded History View */}
          {isExpanded && (
            <div className="p-2 border-t border-white/10">
              {historyTabs.length > 0 ? (
                <>
                  <div className="flex justify-between items-baseline px-2 pb-2">
                    <h3 className="text-sm font-bold">Run History</h3>
                    <p className="text-xs text-gray-400">
                      Avg: {formatElapsedTime(avgDuration)}
                    </p>
                  </div>
                  <div className="max-h-60 overflow-y-auto pr-1">
                    {historyTabs.map((tabState) => (
                      <TabHistory
                        key={tabState.tabId}
                        tabState={tabState}
                        onNavigate={onNavigate}
                      />
                    ))}
                  </div>
                </>
              ) : (
                <p className="text-xs text-gray-400 text-center py-2">
                  No completed runs in this session.
                </p>
              )}
            </div>
          )}
        </div>
      );
    }

    export default Indicator;
  src/content/useDrag.ts: |-
    import { useState, useCallback, RefObject, useEffect, useRef } from 'react';

    const STORAGE_KEY = 'indicator-position';

    interface Position {
      x: number;
      y: number;
    }

    export function useDrag(ref: RefObject<HTMLElement>) {
      const [position, setPosition] = useState<Position>({
        x: window.innerWidth - 250, // Initial position top-right
        y: 20,
      });
      const positionRef = useRef(position);

      // Load position from storage on initial mount
      useEffect(() => {
        chrome.storage.local.get(STORAGE_KEY, (result) => {
          if (
            result[STORAGE_KEY] &&
            typeof result[STORAGE_KEY].x === 'number' &&
            typeof result[STORAGE_KEY].y === 'number'
          ) {
            setPosition(result[STORAGE_KEY]);
          }
        });
      }, []); // Empty dependency array ensures this runs only once on mount

      // Keep ref in sync with state for access in callbacks
      useEffect(() => {
        positionRef.current = position;
      }, [position]);

      const handleMouseDown = useCallback(
        (e: React.MouseEvent<HTMLDivElement>) => {
          // Prevents text selection while dragging
          e.preventDefault();

          const startPos = { x: e.clientX, y: e.clientY };
          const elementStartPos = positionRef.current; // Use ref to get position at drag start
          const element = ref.current;
          if (!element) return;

          const handleMouseMove = (moveEvent: MouseEvent) => {
            const dx = moveEvent.clientX - startPos.x;
            const dy = moveEvent.clientY - startPos.y;
            setPosition({
              x: elementStartPos.x + dx,
              y: elementStartPos.y + dy,
            });
          };

          const handleMouseUp = () => {
            document.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);
            // On mouse up, the drag is over. The `position` state has been updated
            // by the last `handleMouseMove`. The `useEffect` listening to `position`
            // will have updated `positionRef.current`. We can now save it.
            chrome.storage.local.set({ [STORAGE_KEY]: positionRef.current });
          };

          document.addEventListener('mousemove', handleMouseMove);
          document.addEventListener('mouseup', handleMouseUp);
        },
        [ref] // No dependency on `position` state
      );

      return {
        position,
        setPosition, // Expose setPosition for potential programmatic updates
        handleMouseDown,
      };
    }
approved: true
